{
  "version": 3,
  "sources": ["../../../src/internal/selection-to-insertion-end.ts", "../../../node_modules/.pnpm/prosemirror-utils@1.2.2_prosemirror-model@1.21.0_prosemirror-state@1.4.3/node_modules/prosemirror-utils/src/selection.ts", "../../../node_modules/.pnpm/prosemirror-utils@1.2.2_prosemirror-model@1.21.0_prosemirror-state@1.4.3/node_modules/prosemirror-utils/src/helpers.ts", "../../../node_modules/.pnpm/prosemirror-utils@1.2.2_prosemirror-model@1.21.0_prosemirror-state@1.4.3/node_modules/prosemirror-utils/src/transforms.ts", "../../../node_modules/.pnpm/prosemirror-utils@1.2.2_prosemirror-model@1.21.0_prosemirror-state@1.4.3/node_modules/prosemirror-utils/src/node.ts", "../../../node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/src/directive.ts", "../../../node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/src/directives/unsafe-html.ts", "../../../node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/src/directives/if-defined.ts", "../../../node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/src/directives/when.ts", "../../../src/exports/extensions/attachment.ts"],
  "sourcesContent": ["import { Selection, Transaction } from \"@tiptap/pm/state\";\nimport { ReplaceAroundStep, ReplaceStep } from \"@tiptap/pm/transform\";\n\n// source: https://github.com/ueberdosis/tiptap/blob/8c6751f0c638effb22110b62b40a1632ea6867c9/packages/core/src/helpers/selectionToInsertionEnd.ts\nexport function selectionToInsertionEnd(\n  tr: Transaction,\n  startLen: number,\n  bias: number,\n) {\n  const last = tr.steps.length - 1;\n\n  if (last < startLen) {\n    return;\n  }\n\n  const step = tr.steps[last];\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return;\n  }\n\n  const map = tr.mapping.maps[last];\n  let end = 0;\n\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n", "import type { Node as PMNode, ResolvedPos } from 'prosemirror-model';\nimport { Selection } from 'prosemirror-state';\nimport type {\n  FindPredicate,\n  FindResult,\n  DomAtPos,\n  NodeTypeParam,\n} from './types';\nimport { equalNodeType, isNodeSelection } from './helpers';\n\n// Iterates over parent nodes, returning the closest node and its start position `predicate` returns truthy for. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNode(predicate)(selection);\n// ```\nexport const findParentNode =\n  (predicate: FindPredicate) =>\n  (\n    { $from, $to }: Selection,\n    validateSameParent: boolean = false\n  ): FindResult => {\n    // Check if parent are different\n    if (validateSameParent && !$from.sameParent($to)) {\n      // If they are, I need to find a common parent\n      let depth = Math.min($from.depth, $to.depth);\n      while (depth >= 0) {\n        const fromNode = $from.node(depth);\n        const toNode = $to.node(depth);\n        if (toNode === fromNode) {\n          // The have the same parent\n          if (predicate(fromNode)) {\n            // Check the predicate\n            return {\n              // Return the resolved pos\n              pos: depth > 0 ? $from.before(depth) : 0,\n              start: $from.start(depth),\n              depth: depth,\n              node: fromNode,\n            };\n          }\n        }\n        depth = depth - 1; // Keep looking\n      }\n      return;\n    }\n\n    return findParentNodeClosestToPos($from, predicate);\n  };\n\n// Iterates over parent nodes starting from the given `$pos`, returning the closest node and its start position `predicate` returns truthy for. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNodeClosestToPos(state.doc.resolve(5), predicate);\n// ```\nexport const findParentNodeClosestToPos = (\n  $pos: ResolvedPos,\n  predicate: FindPredicate\n): FindResult => {\n  for (let i = $pos.depth; i > 0; i--) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node,\n      };\n    }\n  }\n};\n\n// Iterates over parent nodes, returning DOM reference of the closest node `predicate` returns truthy for.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const predicate = node => node.type === schema.nodes.table;\n// const parent = findParentDomRef(predicate, domAtPos)(selection); // <table>\n// ```\nexport const findParentDomRef =\n  (predicate: FindPredicate, domAtPos: DomAtPos) =>\n  (selection: Selection): Node | undefined => {\n    const parent = findParentNode(predicate)(selection);\n    if (parent) {\n      return findDomRefAtPos(parent.pos, domAtPos);\n    }\n  };\n\n// Checks if there's a parent node `predicate` returns truthy for.\n//\n// ```javascript\n// if (hasParentNode(node => node.type === schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\nexport const hasParentNode =\n  (predicate: FindPredicate) =>\n  (selection: Selection): boolean => {\n    return !!findParentNode(predicate)(selection);\n  };\n\n// Iterates over parent nodes, returning closest node of a given `nodeType`. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const parent = findParentNodeOfType(schema.nodes.paragraph)(selection);\n// ```\nexport const findParentNodeOfType =\n  (nodeType: NodeTypeParam) =>\n  (selection: Selection): FindResult => {\n    return findParentNode((node) => equalNodeType(nodeType, node))(selection);\n  };\n\n// Iterates over parent nodes starting from the given `$pos`, returning closest node of a given `nodeType`. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const parent = findParentNodeOfTypeClosestToPos(state.doc.resolve(10), schema.nodes.paragraph);\n// ```\nexport const findParentNodeOfTypeClosestToPos = (\n  $pos: ResolvedPos,\n  nodeType: NodeTypeParam\n): FindResult => {\n  return findParentNodeClosestToPos($pos, (node: PMNode) =>\n    equalNodeType(nodeType, node)\n  );\n};\n\n// Checks if there's a parent node of a given `nodeType`.\n//\n// ```javascript\n// if (hasParentNodeOfType(schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\nexport const hasParentNodeOfType =\n  (nodeType: NodeTypeParam) =>\n  (selection: Selection): boolean => {\n    return hasParentNode((node) => equalNodeType(nodeType, node))(selection);\n  };\n\n// Iterates over parent nodes, returning DOM reference of the closest node of a given `nodeType`.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const parent = findParentDomRefOfType(schema.nodes.codeBlock, domAtPos)(selection); // <pre>\n// ```\nexport const findParentDomRefOfType =\n  (nodeType: NodeTypeParam, domAtPos: DomAtPos) =>\n  (selection: Selection): Node | undefined => {\n    return findParentDomRef(\n      (node) => equalNodeType(nodeType, node),\n      domAtPos\n    )(selection);\n  };\n\n// Returns a node of a given `nodeType` if it is selected. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const { extension, inlineExtension, bodiedExtension } = schema.nodes;\n// const selectedNode = findSelectedNodeOfType([\n//   extension,\n//   inlineExtension,\n//   bodiedExtension,\n// ])(selection);\n// ```\nexport const findSelectedNodeOfType =\n  (nodeType: NodeTypeParam) =>\n  (selection: Selection): FindResult => {\n    if (isNodeSelection(selection)) {\n      const { node, $from } = selection;\n      if (equalNodeType(nodeType, node)) {\n        return {\n          node,\n          start: $from.start(),\n          pos: $from.pos,\n          depth: $from.depth,\n        };\n      }\n    }\n  };\n\n// Returns position of the previous node.\n//\n// ```javascript\n// const pos = findPositionOfNodeBefore(tr.selection);\n// ```\nexport const findPositionOfNodeBefore = (\n  selection: Selection\n): number | undefined => {\n  const { nodeBefore } = selection.$from;\n  const maybeSelection = Selection.findFrom(selection.$from, -1);\n  if (maybeSelection && nodeBefore) {\n    // leaf node\n    const parent = findParentNodeOfType(nodeBefore.type)(maybeSelection);\n    if (parent) {\n      return parent.pos;\n    }\n    return maybeSelection.$from.pos;\n  }\n};\n\n// Returns DOM reference of a node at a given `position`. If the node type is of type `TEXT_NODE` it will return the reference of the parent node.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const ref = findDomRefAtPos($from.pos, domAtPos);\n// ```\nexport const findDomRefAtPos = (position: number, domAtPos: DomAtPos): Node => {\n  const dom = domAtPos(position);\n  const node = dom.node.childNodes[dom.offset];\n\n  if (dom.node.nodeType === Node.TEXT_NODE && dom.node.parentNode) {\n    return dom.node.parentNode;\n  }\n\n  if (!node || node.nodeType === Node.TEXT_NODE) {\n    return dom.node;\n  }\n\n  return node;\n};\n", "import { Selection, NodeSelection, type Transaction } from 'prosemirror-state';\nimport { Fragment, Node as PMNode, type ResolvedPos } from 'prosemirror-model';\nimport { setTextSelection } from './transforms';\nimport type { NodeTypeParam, Content } from './types';\n\n// Checks if current selection is a `NodeSelection`.\n//\n// ```javascript\n// if (isNodeSelection(tr.selection)) {\n//   // ...\n// }\n// ```\nexport const isNodeSelection = (\n  selection: Selection\n): selection is NodeSelection => {\n  return selection instanceof NodeSelection;\n};\n\n// Checks if the type a given `node` equals to a given `nodeType`.\nexport const equalNodeType = (\n  nodeType: NodeTypeParam,\n  node: PMNode\n): boolean => {\n  return (\n    (Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1) ||\n    node.type === nodeType\n  );\n};\n\n// Creates a new transaction object from a given transaction\nexport const cloneTr = (tr: Transaction): Transaction => {\n  return Object.assign(Object.create(tr), tr).setTime(Date.now());\n};\n\n// Returns a `replace` transaction that replaces a node at a given position with the given `content`.\n// It will return the original transaction if replacing is not possible.\n// `position` should point at the position immediately before the node.\nexport const replaceNodeAtPos =\n  (position: number, content: Content) =>\n  (tr: Transaction): Transaction => {\n    const node = tr.doc.nodeAt(position);\n    const $pos = tr.doc.resolve(position);\n    if (!node) {\n      return tr;\n    }\n\n    if (canReplace($pos, content)) {\n      tr = tr.replaceWith(position, position + node.nodeSize, content);\n      const start = tr.selection.$from.pos - 1;\n      // put cursor inside of the inserted node\n      tr = setTextSelection(Math.max(start, 0), -1)(tr);\n      // move cursor to the start of the node\n      tr = setTextSelection(tr.selection.$from.start())(tr);\n      return cloneTr(tr);\n    }\n    return tr;\n  };\n\n// Checks if replacing a node at a given `$pos` inside of the `doc` node with the given `content` is possible.\nexport const canReplace = ($pos: ResolvedPos, content: Content): boolean => {\n  const node = $pos.node($pos.depth);\n  return (\n    node &&\n    node.type.validContent(\n      content instanceof Fragment ? content : Fragment.from(content)\n    )\n  );\n};\n\n// Returns a `delete` transaction that removes a node at a given position with the given `node`.\n// `position` should point at the position immediately before the node.\nexport const removeNodeAtPos =\n  (position: number) =>\n  (tr: Transaction): Transaction => {\n    const node = tr.doc.nodeAt(position);\n    if (!node) {\n      return tr;\n    }\n\n    return cloneTr(tr.delete(position, position + node.nodeSize));\n  };\n\n// Checks if a given `content` can be inserted at the given `$pos`\n//\n// ```javascript\n// const { selection: { $from } } = state;\n// const node = state.schema.nodes.atom.createChecked();\n// if (canInsert($from, node)) {\n//   // ...\n// }\n// ```\nexport const canInsert = ($pos: ResolvedPos, content: Content): boolean => {\n  const index = $pos.index();\n\n  if (content instanceof Fragment) {\n    return $pos.parent.canReplace(index, index, content);\n  } else if (content instanceof PMNode) {\n    return $pos.parent.canReplaceWith(index, index, content.type);\n  }\n  return false;\n};\n\n// Checks if a given `node` is an empty paragraph\nexport const isEmptyParagraph = (node: PMNode): boolean => {\n  return !node || (node.type.name === 'paragraph' && node.nodeSize === 2);\n};\n\nexport const checkInvalidMovements = (\n  originIndex: number,\n  targetIndex: number,\n  targets: number[],\n  type: unknown\n): boolean => {\n  const direction = originIndex > targetIndex ? -1 : 1;\n  const errorMessage = `Target position is invalid, you can't move the ${type} ${originIndex} to ${targetIndex}, the target can't be split. You could use tryToFit option.`;\n\n  if (direction === 1) {\n    if (targets.slice(0, targets.length - 1).indexOf(targetIndex) !== -1) {\n      throw new Error(errorMessage);\n    }\n  } else {\n    if (targets.slice(1).indexOf(targetIndex) !== -1) {\n      throw new Error(errorMessage);\n    }\n  }\n\n  return true;\n};\n", "import { NodeSelection, Selection, type Transaction } from 'prosemirror-state';\nimport {\n  Fragment,\n  Node as PMNode,\n  type NodeType,\n  Mark,\n} from 'prosemirror-model';\nimport { findParentNodeOfType, findPositionOfNodeBefore } from './selection';\nimport {\n  cloneTr,\n  isNodeSelection,\n  replaceNodeAtPos,\n  removeNodeAtPos,\n  canInsert,\n  isEmptyParagraph,\n} from './helpers';\nimport type { Attrs, NodeTypeParam, Content } from './types';\n\n// Returns a new transaction that removes a node of a given `nodeType`. It will return an original transaction if parent node hasn't been found.\n//\n// ```javascript\n// dispatch(\n//   removeParentNodeOfType(schema.nodes.table)(tr)\n// );\n// ```\nexport const removeParentNodeOfType =\n  (nodeType: NodeTypeParam) =>\n  (tr: Transaction): Transaction => {\n    const parent = findParentNodeOfType(nodeType)(tr.selection);\n    if (parent) {\n      return removeNodeAtPos(parent.pos)(tr);\n    }\n    return tr;\n  };\n\n// Returns a new transaction that replaces parent node of a given `nodeType` with the given `content`. It will return an original transaction if either parent node hasn't been found or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n//\n// dispatch(\n//  replaceParentNodeOfType(schema.nodes.table, node)(tr)\n// );\n// ```\nexport const replaceParentNodeOfType =\n  (nodeType: NodeTypeParam, content: Content) =>\n  (tr: Transaction): Transaction => {\n    if (!Array.isArray(nodeType)) {\n      nodeType = [nodeType];\n    }\n    for (let i = 0, count = nodeType.length; i < count; i++) {\n      const parent = findParentNodeOfType(nodeType[i])(tr.selection);\n      if (parent) {\n        const newTr = replaceNodeAtPos(parent.pos, content)(tr);\n        if (newTr !== tr) {\n          return newTr;\n        }\n      }\n    }\n    return tr;\n  };\n\n// Returns a new transaction that removes selected node. It will return an original transaction if current selection is not a `NodeSelection`.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedNode(tr)\n// );\n// ```\nexport const removeSelectedNode = (tr: Transaction): Transaction => {\n  if (isNodeSelection(tr.selection)) {\n    const from = tr.selection.$from.pos;\n    const to = tr.selection.$to.pos;\n    return cloneTr(tr.delete(from, to));\n  }\n  return tr;\n};\n\n// Returns a new transaction that replaces selected node with a given `node`, keeping NodeSelection on the new `node`.\n// It will return the original transaction if either current selection is not a NodeSelection or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n// dispatch(\n//   replaceSelectedNode(node)(tr)\n// );\n// ```\nexport const replaceSelectedNode =\n  (content: Content) =>\n  (tr: Transaction): Transaction => {\n    if (isNodeSelection(tr.selection)) {\n      const { $from, $to } = tr.selection;\n      if (\n        (content instanceof Fragment &&\n          $from.parent.canReplace(\n            $from.index(),\n            $from.indexAfter(),\n            content\n          )) ||\n        (content instanceof PMNode &&\n          $from.parent.canReplaceWith(\n            $from.index(),\n            $from.indexAfter(),\n            content.type\n          ))\n      ) {\n        return cloneTr(\n          tr\n            .replaceWith($from.pos, $to.pos, content)\n            // restore node selection\n            .setSelection(new NodeSelection(tr.doc.resolve($from.pos)))\n        );\n      }\n    }\n    return tr;\n  };\n\n// Returns a new transaction that tries to find a valid cursor selection starting at the given `position`\n// and searching back if `dir` is negative, and forward if positive.\n// If a valid cursor position hasn't been found, it will return the original transaction.\n//\n// ```javascript\n// dispatch(\n//   setTextSelection(5)(tr)\n// );\n// ```\nexport const setTextSelection =\n  (position: number, dir = 1) =>\n  (tr: Transaction): Transaction => {\n    const nextSelection = Selection.findFrom(\n      tr.doc.resolve(position),\n      dir,\n      true\n    );\n    if (nextSelection) {\n      return tr.setSelection(nextSelection);\n    }\n    return tr;\n  };\n\nconst isSelectableNode = (node: Content): node is PMNode =>\n  Boolean(node instanceof PMNode && node.type && node.type.spec.selectable);\nconst shouldSelectNode = (node: Content): boolean =>\n  isSelectableNode(node) && node.type.isLeaf;\n\nconst setSelection = (\n  node: Content,\n  pos: number,\n  tr: Transaction\n): Transaction => {\n  if (shouldSelectNode(node)) {\n    return tr.setSelection(new NodeSelection(tr.doc.resolve(pos)));\n  }\n  return setTextSelection(pos)(tr);\n};\n\n// Returns a new transaction that inserts a given `content` at the current cursor position, or at a given `position`, if it is allowed by schema. If schema restricts such nesting, it will try to find an appropriate place for a given node in the document, looping through parent nodes up until the root document node.\n// If `tryToReplace` is true and current selection is a NodeSelection, it will replace selected node with inserted content if its allowed by schema.\n// If cursor is inside of an empty paragraph, it will try to replace that paragraph with the given content. If insertion is successful and inserted node has content, it will set cursor inside of that content.\n// It will return an original transaction if the place for insertion hasn't been found.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   safeInsert(node)(tr)\n// );\n// ```\nexport const safeInsert =\n  (content: Content, position?: number, tryToReplace?: boolean) =>\n  (tr: Transaction): Transaction => {\n    const hasPosition = typeof position === 'number';\n    const { $from } = tr.selection;\n    const $insertPos = hasPosition\n      ? tr.doc.resolve(position)\n      : isNodeSelection(tr.selection)\n      ? tr.doc.resolve($from.pos + 1)\n      : $from;\n    const { parent } = $insertPos;\n\n    // try to replace selected node\n    if (isNodeSelection(tr.selection) && tryToReplace) {\n      const oldTr = tr;\n      tr = replaceSelectedNode(content)(tr);\n      if (oldTr !== tr) {\n        return tr;\n      }\n    }\n\n    // try to replace an empty paragraph\n    if (isEmptyParagraph(parent)) {\n      const oldTr = tr;\n      tr = replaceParentNodeOfType(parent.type, content)(tr);\n      if (oldTr !== tr) {\n        const pos = isSelectableNode(content)\n          ? // for selectable node, selection position would be the position of the replaced parent\n            $insertPos.before($insertPos.depth)\n          : $insertPos.pos;\n        return setSelection(content, pos, tr);\n      }\n    }\n\n    // given node is allowed at the current cursor position\n    if (canInsert($insertPos, content)) {\n      tr.insert($insertPos.pos, content);\n      const pos = hasPosition\n        ? $insertPos.pos\n        : isSelectableNode(content)\n        ? // for atom nodes selection position after insertion is the previous pos\n          tr.selection.$anchor.pos - 1\n        : tr.selection.$anchor.pos;\n      return cloneTr(setSelection(content, pos, tr));\n    }\n\n    // looking for a place in the doc where the node is allowed\n    for (let i = $insertPos.depth; i > 0; i--) {\n      const pos = $insertPos.after(i);\n      const $pos = tr.doc.resolve(pos);\n      if (canInsert($pos, content)) {\n        tr.insert(pos, content);\n        return cloneTr(setSelection(content, pos, tr));\n      }\n    }\n    return tr;\n  };\n\n// Returns a transaction that changes the type, attributes, and/or marks of the parent node of a given `nodeType`.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   setParentNodeMarkup(schema.nodes.panel, null, { panelType })(tr);\n// );\n// ```\nexport const setParentNodeMarkup =\n  (\n    nodeType: NodeTypeParam,\n    type: NodeType | null,\n    attrs?: Attrs | null,\n    marks?: Array<Mark> | ReadonlyArray<Mark>\n  ) =>\n  (tr: Transaction): Transaction => {\n    const parent = findParentNodeOfType(nodeType)(tr.selection);\n    if (parent) {\n      return cloneTr(\n        tr.setNodeMarkup(\n          parent.pos,\n          type,\n          Object.assign({}, parent.node.attrs, attrs),\n          marks\n        )\n      );\n    }\n    return tr;\n  };\n\n// Returns a new transaction that sets a `NodeSelection` on a parent node of a `given nodeType`.\n//\n// ```javascript\n// dispatch(\n//   selectParentNodeOfType([tableCell, tableHeader])(state.tr)\n// );\n// ```\nexport const selectParentNodeOfType =\n  (nodeType: NodeTypeParam) =>\n  (tr: Transaction): Transaction => {\n    if (!isNodeSelection(tr.selection)) {\n      const parent = findParentNodeOfType(nodeType)(tr.selection);\n      if (parent) {\n        return cloneTr(\n          tr.setSelection(NodeSelection.create(tr.doc, parent.pos))\n        );\n      }\n    }\n    return tr;\n  };\n\n// Returns a new transaction that deletes previous node.\n//\n// ```javascript\n// dispatch(\n//   removeNodeBefore(state.tr)\n// );\n// ```\nexport const removeNodeBefore = (tr: Transaction): Transaction => {\n  const position = findPositionOfNodeBefore(tr.selection);\n  if (typeof position === 'number') {\n    return removeNodeAtPos(position)(tr);\n  }\n  return tr;\n};\n", "import { type Node as PMNode, MarkType, NodeType } from 'prosemirror-model';\nimport type { Attrs } from './types';\n\ntype FindChildrenAttrsPredicate = (attrs: Attrs) => boolean;\ntype FindNodesResult = Array<{ node: PMNode; pos: number }>;\ntype FindChildrenPredicate = (node: PMNode) => boolean;\n\n// Flattens descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const children = flatten(node);\n// ```\nexport const flatten = (\n  node: PMNode,\n  descend: boolean = true\n): FindNodesResult => {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  }\n  const result: FindNodesResult = [];\n  node.descendants((child, pos) => {\n    result.push({ node: child, pos });\n    if (!descend) {\n      return false;\n    }\n  });\n  return result;\n};\n\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findChildren(node, child => child.isText, false);\n// ```\nexport const findChildren = (\n  node: PMNode,\n  predicate: FindChildrenPredicate,\n  descend: boolean = true\n): FindNodesResult => {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  } else if (!predicate) {\n    throw new Error('Invalid \"predicate\" parameter');\n  }\n  return flatten(node, descend).filter((child) => predicate(child.node));\n};\n\n// Returns text nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findTextNodes(node);\n// ```\nexport const findTextNodes = (\n  node: PMNode,\n  descend: boolean = true\n): FindNodesResult => {\n  return findChildren(node, (child) => child.isText, descend);\n};\n\n// Returns inline nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const inlineNodes = findInlineNodes(node);\n// ```\nexport const findInlineNodes = (\n  node: PMNode,\n  descend: boolean = true\n): FindNodesResult => {\n  return findChildren(node, (child) => child.isInline, descend);\n};\n\n// Returns block descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const blockNodes = findBlockNodes(node);\n// ```\nexport const findBlockNodes = (\n  node: PMNode,\n  descend: boolean = true\n): FindNodesResult => {\n  return findChildren(node, (child) => child.isBlock, descend);\n};\n\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const mergedCells = findChildrenByAttr(table, attrs => attrs.colspan === 2);\n// ```\nexport const findChildrenByAttr = (\n  node: PMNode,\n  predicate: FindChildrenAttrsPredicate,\n  descend: boolean = true\n): FindNodesResult => {\n  return findChildren(node, (child) => !!predicate(child.attrs), descend);\n};\n\n// Iterates over descendants of a given `node`, returning child nodes of a given nodeType. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const cells = findChildrenByType(table, schema.nodes.tableCell);\n// ```\nexport const findChildrenByType = (\n  node: PMNode,\n  nodeType: NodeType,\n  descend: boolean = true\n): FindNodesResult => {\n  return findChildren(node, (child) => child.type === nodeType, descend);\n};\n\n// Iterates over descendants of a given `node`, returning child nodes that have a mark of a given markType. It doesn't descend into a `node` when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const nodes = findChildrenByMark(state.doc, schema.marks.strong);\n// ```\nexport const findChildrenByMark = (\n  node: PMNode,\n  markType: MarkType,\n  descend: boolean = true\n): FindNodesResult => {\n  return findChildren(\n    node,\n    (child) => Boolean(markType.isInSet(child.marks)),\n    descend\n  );\n};\n\n// Returns `true` if a given node contains nodes of a given `nodeType`\n//\n// ```javascript\n// if (contains(panel, schema.nodes.listItem)) {\n//   // ...\n// }\n// ```\nexport const contains = (node: PMNode, nodeType: NodeType): boolean => {\n  return !!findChildrenByType(node, nodeType).length;\n};\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Disconnectable, Part} from './lit-html.js';\n\nexport {\n  AttributePart,\n  BooleanAttributePart,\n  ChildPart,\n  ElementPart,\n  EventPart,\n  Part,\n  PropertyPart,\n} from './lit-html.js';\n\nexport interface DirectiveClass {\n  new (part: PartInfo): Directive;\n}\n\n/**\n * This utility type extracts the signature of a directive class's render()\n * method so we can use it for the type of the generated directive function.\n */\nexport type DirectiveParameters<C extends Directive> = Parameters<C['render']>;\n\n/**\n * A generated directive function doesn't evaluate the directive, but just\n * returns a DirectiveResult object that captures the arguments.\n */\nexport interface DirectiveResult<C extends DirectiveClass = DirectiveClass> {\n  /**\n   * This property needs to remain unminified.\n   * @internal */\n  ['_$litDirective$']: C;\n  /** @internal */\n  values: DirectiveParameters<InstanceType<C>>;\n}\n\nexport const PartType = {\n  ATTRIBUTE: 1,\n  CHILD: 2,\n  PROPERTY: 3,\n  BOOLEAN_ATTRIBUTE: 4,\n  EVENT: 5,\n  ELEMENT: 6,\n} as const;\n\nexport type PartType = (typeof PartType)[keyof typeof PartType];\n\nexport interface ChildPartInfo {\n  readonly type: typeof PartType.CHILD;\n}\n\nexport interface AttributePartInfo {\n  readonly type:\n    | typeof PartType.ATTRIBUTE\n    | typeof PartType.PROPERTY\n    | typeof PartType.BOOLEAN_ATTRIBUTE\n    | typeof PartType.EVENT;\n  readonly strings?: ReadonlyArray<string>;\n  readonly name: string;\n  readonly tagName: string;\n}\n\nexport interface ElementPartInfo {\n  readonly type: typeof PartType.ELEMENT;\n}\n\n/**\n * Information about the part a directive is bound to.\n *\n * This is useful for checking that a directive is attached to a valid part,\n * such as with directive that can only be used on attribute bindings.\n */\nexport type PartInfo = ChildPartInfo | AttributePartInfo | ElementPartInfo;\n\n/**\n * Creates a user-facing directive function from a Directive class. This\n * function has the same parameters as the directive's render() method.\n */\nexport const directive =\n  <C extends DirectiveClass>(c: C) =>\n  (...values: DirectiveParameters<InstanceType<C>>): DirectiveResult<C> => ({\n    // This property needs to remain unminified.\n    ['_$litDirective$']: c,\n    values,\n  });\n\n/**\n * Base class for creating custom directives. Users should extend this class,\n * implement `render` and/or `update`, and then pass their subclass to\n * `directive`.\n */\nexport abstract class Directive implements Disconnectable {\n  //@internal\n  __part!: Part;\n  //@internal\n  __attributeIndex: number | undefined;\n  //@internal\n  __directive?: Directive;\n\n  //@internal\n  _$parent!: Disconnectable;\n\n  // These will only exist on the AsyncDirective subclass\n  //@internal\n  _$disconnectableChildren?: Set<Disconnectable>;\n  // This property needs to remain unminified.\n  //@internal\n  ['_$notifyDirectiveConnectionChanged']?(isConnected: boolean): void;\n\n  constructor(_partInfo: PartInfo) {}\n\n  // See comment in Disconnectable interface for why this is a getter\n  get _$isConnected() {\n    return this._$parent._$isConnected;\n  }\n\n  /** @internal */\n  _$initialize(\n    part: Part,\n    parent: Disconnectable,\n    attributeIndex: number | undefined\n  ) {\n    this.__part = part;\n    this._$parent = parent;\n    this.__attributeIndex = attributeIndex;\n  }\n  /** @internal */\n  _$resolve(part: Part, props: Array<unknown>): unknown {\n    return this.update(part, props);\n  }\n\n  abstract render(...props: Array<unknown>): unknown;\n\n  update(_part: Part, props: Array<unknown>): unknown {\n    return this.render(...props);\n  }\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {nothing, TemplateResult, noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\n\nconst HTML_RESULT = 1;\n\nexport class UnsafeHTMLDirective extends Directive {\n  static directiveName = 'unsafeHTML';\n  static resultType = HTML_RESULT;\n\n  private _value: unknown = nothing;\n  private _templateResult?: TemplateResult;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error(\n        `${\n          (this.constructor as typeof UnsafeHTMLDirective).directiveName\n        }() can only be used in child bindings`\n      );\n    }\n  }\n\n  render(value: string | typeof nothing | typeof noChange | undefined | null) {\n    if (value === nothing || value == null) {\n      this._templateResult = undefined;\n      return (this._value = value);\n    }\n    if (value === noChange) {\n      return value;\n    }\n    if (typeof value != 'string') {\n      throw new Error(\n        `${\n          (this.constructor as typeof UnsafeHTMLDirective).directiveName\n        }() called with a non-string value`\n      );\n    }\n    if (value === this._value) {\n      return this._templateResult;\n    }\n    this._value = value;\n    const strings = [value] as unknown as TemplateStringsArray;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (strings as any).raw = strings;\n    // WARNING: impersonating a TemplateResult like this is extremely\n    // dangerous. Third-party directives should not do this.\n    return (this._templateResult = {\n      // Cast to a known set of integers that satisfy ResultType so that we\n      // don't have to export ResultType and possibly encourage this pattern.\n      // This property needs to remain unminified.\n      ['_$litType$']: (this.constructor as typeof UnsafeHTMLDirective)\n        .resultType as 1 | 2,\n      strings,\n      values: [],\n    });\n  }\n}\n\n/**\n * Renders the result as HTML, rather than text.\n *\n * The values `undefined`, `null`, and `nothing`, will all result in no content\n * (empty string) being rendered.\n *\n * Note, this is unsafe to use with any user-provided input that hasn't been\n * sanitized or escaped, as it may lead to cross-site-scripting\n * vulnerabilities.\n */\nexport const unsafeHTML = directive(UnsafeHTMLDirective);\n", "/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {nothing} from '../lit-html.js';\n\n/**\n * For AttributeParts, sets the attribute if the value is defined and removes\n * the attribute if the value is undefined.\n *\n * For other part types, this directive is a no-op.\n */\nexport const ifDefined = <T>(value: T) => value ?? nothing;\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/**\n * When `condition` is true, returns the result of calling `trueCase()`, else\n * returns the result of calling `falseCase()` if `falseCase` is defined.\n *\n * This is a convenience wrapper around a ternary expression that makes it a\n * little nicer to write an inline conditional without an else.\n *\n * @example\n *\n * ```ts\n * render() {\n *   return html`\n *     ${when(this.user, () => html`User: ${this.user.username}`, () => html`Sign In...`)}\n *   `;\n * }\n * ```\n */\nexport function when<T, F>(\n  condition: true,\n  trueCase: () => T,\n  falseCase?: () => F\n): T;\nexport function when<T, F = undefined>(\n  condition: false,\n  trueCase: () => T,\n  falseCase?: () => F\n): F;\nexport function when<T, F = undefined>(\n  condition: unknown,\n  trueCase: () => T,\n  falseCase?: () => F\n): T | F;\nexport function when(\n  condition: unknown,\n  trueCase: () => unknown,\n  falseCase?: () => unknown\n): unknown {\n  return condition ? trueCase() : falseCase?.();\n}\n", "import {\n  AttachmentManager,\n  AttachmentManagerAttributes,\n} from \"../attachment-manager.js\";\nimport { LOADING_STATES } from \"../elements/attachment-editor.js\";\nimport type { LoadingState } from \"../elements/attachment-editor.js\";\nimport { CommandProps, mergeAttributes, Node } from \"@tiptap/core\";\nimport { selectionToInsertionEnd } from \"../../internal/selection-to-insertion-end.js\";\nimport { Maybe } from \"../../types\";\nimport { findAttribute } from \"./find-attribute.js\";\nimport { toDefaultCaption } from \"../../internal/to-default-caption.js\";\nimport { fileUploadErrorMessage, captionPlaceholder } from \"../translations.js\";\nimport {\n  findChildrenByType,\n  findParentNodeOfTypeClosestToPos,\n} from \"prosemirror-utils\";\nimport { AttachmentRemoveEvent } from \"../events/attachment-remove-event.js\";\n\nimport { render, html } from \"lit/html.js\";\nimport { unsafeHTML } from \"lit/directives/unsafe-html.js\";\nimport { ifDefined } from \"lit/directives/if-defined.js\";\nimport { when } from \"lit/directives/when.js\";\n\nimport {\n  EditorState,\n  NodeSelection,\n  Plugin,\n  PluginKey,\n  TextSelection,\n  Transaction,\n} from \"@tiptap/pm/state\";\nimport {\n  DOMSerializer,\n  Node as ProseMirrorNode,\n  ResolvedPos,\n} from \"@tiptap/pm/model\";\n\ninterface AttachmentAttrs extends AttachmentManagerAttributes {\n  loadingState: LoadingState;\n  previewable: boolean;\n  progress: number;\n\n  // Image\n  width?: Maybe<number>;\n  height?: Maybe<number>;\n\n  [key: string]: unknown;\n}\n\nexport interface AttachmentOptions {\n  HTMLAttributes: Record<string, any>;\n  fileUploadErrorMessage: string;\n  captionPlaceholder: string;\n  previewable: boolean;\n}\n\ndeclare module \"@tiptap/core\" {\n  interface Commands<ReturnType> {\n    attachment: {\n      /**\n       * Add an attachment(s)\n       */\n      setAttachment: (\n        options: AttachmentManager | AttachmentManager[],\n      ) => ReturnType;\n\n      /**\n       * Allows you to insert an attachment at a location within TipTap\n       */\n      setAttachmentAtCoords: (\n        options: AttachmentManager | AttachmentManager[],\n        coordinates: { top: number; left: number },\n      ) => ReturnType;\n    };\n  }\n}\n\nexport const figureTypes = [\n  \"previewable-attachment-figure\",\n  \"attachment-figure\",\n];\n\n/**\n * This is a special case where it exists as:\n * figure[\"data-trix-attachment\"][\"contentType\"] and\n * action-text-attachment[\"content-type\"]\n */\nfunction parseContentTypeFromElement(element: HTMLElement) {\n  return (\n    findAttribute(element, \"content-type\") ||\n    JSON.parse(element.getAttribute(\"data-trix-attachment\") || \"{}\")\n      .contentType ||\n    \"application/octet-stream\"\n  );\n}\n\nconst canParseAttachment = (\n  node: HTMLElement | string,\n  shouldPreview: boolean,\n) => {\n  if (node instanceof HTMLElement) {\n    const contentType = parseContentTypeFromElement(node);\n\n    if (contentType === \"application/octet-stream\") {\n      return false;\n    }\n\n    // For <action-text-attachment>\n    const actionTextAttachment = node.closest(\"action-text-attachment\");\n    if (actionTextAttachment) {\n      const previewable =\n        actionTextAttachment.getAttribute(\"previewable\") === \"true\";\n\n      if (!actionTextAttachment.getAttribute(\"sgid\")) {\n        return false;\n      }\n\n      if (previewable === shouldPreview) {\n        return true;\n      }\n\n      return false;\n    }\n\n    const previewable = canPreview(\n      findAttribute(node, \"previewable\"),\n      findAttribute(node, \"contentType\"),\n    );\n\n    if (previewable === shouldPreview) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * This appends to the current HTML of the <figcaption> into node.attrs.caption.\n * This is how a figcaption knows if it's empty and is important for ActionText.\n */\nfunction handleCaptions(\n  node: ProseMirrorNode,\n  tr: Transaction,\n  newState: EditorState,\n  pos: number,\n) {\n  let modified = false;\n\n  if (figureTypes.includes(node.type.name) === false) return modified;\n\n  // @see https://discuss.prosemirror.net/t/saving-content-containing-dom-generated-by-nodeview/2594/5\n  let scratch = document.createElement(\"div\");\n  scratch.appendChild(\n    DOMSerializer.fromSchema(newState.schema).serializeNode(node),\n  );\n\n  const figcaption = scratch.querySelector(\"figcaption\");\n\n  if (figcaption == null) return modified;\n\n  const caption = figcaption.innerHTML;\n  if (node.attrs.caption !== caption) {\n    tr.setNodeMarkup(pos, undefined, {\n      ...node.attrs,\n      caption,\n    });\n    modified = true;\n  }\n\n  return modified;\n}\n\nfunction canPreview(previewable: boolean, contentType: Maybe<string>): boolean {\n  return Boolean(\n    previewable || AttachmentManager.isPreviewable(contentType || \"\"),\n  );\n}\n\nfunction toExtension(fileName: Maybe<string>): string {\n  if (!fileName) return \"\";\n\n  return \"attachment--\" + fileName.match(/\\.(\\w+)$/)?.[1].toLowerCase();\n}\n\nfunction toType(content: Maybe<string>, previewable: Boolean): string {\n  if (previewable) {\n    return \"attachment--preview\";\n  }\n\n  if (content) {\n    return \"attachment--content\";\n  }\n\n  return \"attachment--file\";\n}\n\nexport const Attachment = Node.create<AttachmentOptions>({\n  name: \"attachment-figure\",\n  group: \"block attachmentFigure\",\n  content: \"inline*\",\n  selectable: true,\n  draggable: true,\n  isolating: true,\n  defining: true,\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey(\"rhino-attachment-fixer\"),\n        appendTransaction(_transactions, _oldState, newState) {\n          const tr = newState.tr;\n          let modified = false;\n\n          // @TODO: Iterate through transactions instead of descendants (?).\n          newState.doc.descendants((node, pos, _parent) => {\n            const mutations = [handleCaptions(node, tr, newState, pos)];\n\n            const shouldModify = mutations.some((bool) => bool === true);\n\n            if (shouldModify) {\n              modified = true;\n            }\n          });\n\n          if (modified) return tr;\n\n          return undefined;\n        },\n      }),\n      new Plugin({\n        key: new PluginKey(\"rhino-prevent-unintended-figcaption-behavior\"),\n        props: {\n          handlePaste: (view, event) => {\n            const name = view.state.selection.$anchor.parent.type.name;\n\n            const { clipboardData } = event;\n\n            if (!clipboardData) return false;\n\n            if (figureTypes.includes(name)) {\n              event.preventDefault();\n              const tr = view.state.tr;\n              // @TODO: Ideally we don't need to do this. This prevents inserting unnecessary <p> tags in the figcaption\n              // causing things to get fubar and <p> to get inserted in a bizarre place.\n              const text = clipboardData.getData(\"text/plain\");\n              tr.insertText(text);\n              view.dispatch(tr);\n              return true;\n            }\n            return false;\n          },\n          handleKeyDown: (view, event) => {\n            /**\n             * This is a hack. When we have an empty figcaption and you press \"Enter\" or \"Backspace\" you delete the\n             * containing gallery.\n             */\n            if ([\"Backspace\", \"Enter\"].includes(event.key)) {\n              const name = view.state.selection.$head.parent.type.name;\n              const content = view.state.selection.$head.parent.textContent;\n\n              if (view.state.selection.to !== view.state.selection.from) {\n                return false;\n              }\n\n              if (figureTypes.includes(name) && content === \"\") {\n                event.preventDefault();\n                return true;\n              }\n            }\n\n            return false;\n          },\n        },\n      }),\n      new Plugin({\n        key: new PluginKey(\"rhino-attachment-remove-event\"),\n        view() {\n          type FindNodeResult = ReturnType<typeof findChildrenByType>;\n          type FindNodeResultObj = FindNodeResult[keyof FindNodeResult];\n\n          const afterSgidsAndAttachmentIds = new Map<\n            string,\n            FindNodeResultObj\n          >();\n\n          return {\n            update(view, prevState) {\n              const nodeTypes = [\n                view.state.schema.nodes[\"previewable-attachment-figure\"],\n                view.state.schema.nodes[\"attachment-figure\"],\n              ];\n\n              nodeTypes.forEach((nodeType) => {\n                const attachmentNodesBefore = findChildrenByType(\n                  prevState.doc,\n                  nodeType,\n                );\n\n                // attachmentNodesAfter state transform\n                findChildrenByType(view.state.doc, nodeType).forEach((node) => {\n                  const nodeAttrs = node.node\n                    .attrs as AttachmentManagerAttributes;\n                  const sgid = nodeAttrs.sgid;\n                  const attachmentId = nodeAttrs.attachmentId;\n\n                  if (sgid) {\n                    afterSgidsAndAttachmentIds.set(sgid, node);\n                  }\n\n                  if (attachmentId) {\n                    afterSgidsAndAttachmentIds.set(attachmentId, node);\n                  }\n                });\n\n                attachmentNodesBefore.forEach((node) => {\n                  const nodeAttrs = node.node\n                    .attrs as AttachmentManagerAttributes;\n\n                  const { sgid, attachmentId } = nodeAttrs;\n\n                  if (sgid && afterSgidsAndAttachmentIds.has(sgid)) return;\n                  if (\n                    attachmentId &&\n                    afterSgidsAndAttachmentIds.has(attachmentId)\n                  )\n                    return;\n\n                  const attachmentManager = new AttachmentManager(\n                    nodeAttrs,\n                    view,\n                  );\n\n                  view.dom.dispatchEvent(\n                    new AttachmentRemoveEvent(attachmentManager),\n                  );\n                });\n\n                afterSgidsAndAttachmentIds.clear();\n              });\n            },\n          };\n        },\n      }),\n    ];\n  },\n  addOptions() {\n    return {\n      HTMLAttributes: {\n        class: \"attachment\",\n      },\n      fileUploadErrorMessage: fileUploadErrorMessage,\n      captionPlaceholder: captionPlaceholder,\n      previewable: false,\n    };\n  },\n\n  parseHTML() {\n    return [\n      // When it's <figure data-trix-attachment> its coming from `to_trix_html`\n      {\n        tag: \"figure[data-trix-attachment]\",\n        getAttrs: (node) => {\n          const isValid = canParseAttachment(node, this.options.previewable);\n\n          if (!isValid) {\n            return false;\n          }\n\n          return null;\n        },\n      },\n      // When it's .attachment, its coming from <action-text-attachment><figure></figure></action-text-attachment> its the raw HTML.\n      {\n        tag: \"action-text-attachment > figure.attachment\",\n        contentElement: \"figcaption\",\n        getAttrs: (node) => {\n          const isValid = canParseAttachment(node, this.options.previewable);\n\n          if (!isValid) {\n            return false;\n          }\n\n          return null;\n        },\n      },\n      {\n        tag: \"action-text-attachment\",\n        getAttrs: (node) => {\n          const isValid = canParseAttachment(node, this.options.previewable);\n\n          if (!isValid) {\n            return false;\n          }\n\n          return null;\n        },\n      },\n    ];\n  },\n\n  renderHTML({ node }) {\n    const {\n      // Figure\n      content,\n      contentType,\n      sgid,\n      fileName,\n      fileSize,\n      caption,\n      url,\n      previewable,\n\n      // Image\n      src,\n      width,\n      height,\n    } = node.attrs as AttachmentAttrs;\n\n    const attachmentAttrs = {\n      caption,\n      contentType,\n      content,\n      filename: fileName,\n      filesize: fileSize,\n      height,\n      width,\n      sgid,\n      url,\n      src,\n    };\n\n    const figure = [\n      \"figure\",\n      mergeAttributes(this.options.HTMLAttributes, {\n        class:\n          this.options.HTMLAttributes.class +\n          \" \" +\n          toType(content, canPreview(previewable, contentType)) +\n          \" \" +\n          toExtension(fileName),\n        \"data-trix-content-type\": contentType,\n        \"data-trix-attachment\": JSON.stringify(attachmentAttrs),\n        \"data-trix-attributes\": JSON.stringify({\n          caption,\n          ...(canPreview(previewable, contentType)\n            ? { presentation: \"gallery\" }\n            : {}),\n        }),\n      }),\n    ] as const;\n\n    const figcaption = [\n      \"figcaption\",\n      mergeAttributes(\n        {},\n        { class: \"attachment__caption attachment__caption--edited\" },\n      ),\n      0,\n    ] as const;\n\n    const image = [\n      \"img\",\n      mergeAttributes(\n        {},\n        {\n          src: url || src,\n          contenteditable: false,\n          width,\n          height,\n        },\n      ),\n    ];\n\n    if (!content && canPreview(previewable, contentType)) {\n      return [...figure, image, figcaption];\n    }\n\n    return [...figure, figcaption];\n  },\n\n  addAttributes() {\n    return {\n      attachmentId: { default: null },\n      caption: {\n        default: \"\",\n        parseHTML: (element) => {\n          return (\n            element.querySelector(\"figcaption\")?.innerHTML ||\n            findAttribute(element, \"caption\")\n          );\n        },\n      },\n      progress: {\n        default: 0,\n        parseHTML: (element) => {\n          return findAttribute(element, \"sgid\") ||\n            findAttribute(element, \"content\") ||\n            element.closest(\"action-text-attachment\")?.innerHTML\n            ? 100\n            : 0;\n        },\n      },\n      loadingState: {\n        default: LOADING_STATES.notStarted,\n        parseHTML: (element) =>\n          findAttribute(element, \"sgid\")\n            ? LOADING_STATES.success\n            : LOADING_STATES.notStarted,\n      },\n      sgid: {\n        default: \"\",\n        parseHTML: (element) => findAttribute(element, \"sgid\"),\n      },\n      src: {\n        default: \"\",\n        parseHTML: (element) => findAttribute(element, \"src\"),\n      },\n      height: {\n        default: \"\",\n        parseHTML: (element) => findAttribute(element, \"height\"),\n      },\n      width: {\n        default: \"\",\n        parseHTML: (element) => {\n          return findAttribute(element, \"width\");\n        },\n      },\n      contentType: {\n        default: \"\",\n        parseHTML: (element) => {\n          return parseContentTypeFromElement(element);\n        },\n      },\n      fileName: {\n        default: \"\",\n        parseHTML: (element) => findAttribute(element, \"filename\"),\n      },\n      fileSize: {\n        default: \"\",\n        parseHTML: (element) => findAttribute(element, \"filesize\"),\n      },\n      content: {\n        default: \"\",\n        parseHTML: (element) => {\n          const attachment = element.closest(\"action-text-attachment\");\n\n          let content = \"\";\n\n          if (attachment) {\n            const domParser = new DOMParser();\n            const parsedDom = domParser.parseFromString(\n              attachment.innerHTML,\n              \"text/html\",\n            );\n\n            const firstChild = parsedDom.body.firstElementChild;\n\n            if (firstChild) {\n              if (\n                firstChild.tagName.toLowerCase() !== \"figure\" ||\n                !firstChild.classList.contains(\"attachment\")\n              ) {\n                content = attachment.innerHTML;\n              }\n            }\n          }\n\n          return content || findAttribute(element, \"content\");\n        },\n      },\n      url: {\n        default: \"\",\n        parseHTML: (element) => {\n          return findAttribute(element, \"url\");\n        },\n      },\n      previewable: {\n        default: false,\n        parseHTML: (element) => {\n          let { previewable } = JSON.parse(\n            element.getAttribute(\"data-trix-attachment\") || \"{}\",\n          );\n\n          if (previewable == null) {\n            previewable = findAttribute(element, \"previewable\");\n          }\n\n          return previewable;\n        },\n      },\n    };\n  },\n\n  addNodeView() {\n    return ({ node, getPos, editor }) => {\n      const {\n        content,\n        contentType,\n        sgid,\n        fileName,\n        progress,\n        fileSize,\n        url,\n        src,\n        width,\n        height,\n        caption,\n        previewable,\n        loadingState,\n      } = node.attrs as AttachmentAttrs;\n\n      const trixAttachment = JSON.stringify({\n        contentType,\n        content,\n        filename: fileName,\n        filesize: fileSize,\n        height,\n        width,\n        sgid,\n        url,\n        caption,\n      });\n\n      const isPreviewable = canPreview(previewable, contentType);\n\n      const trixAttributes = JSON.stringify({\n        ...(isPreviewable ? { presentation: \"gallery\" } : {}),\n        caption,\n      });\n\n      const figureClasses = `\n        ${this.options.HTMLAttributes.class}\n        ${toType(content, canPreview(previewable, contentType))}\n        ${toExtension(fileName)}\n      `;\n\n      function handleFigureClick(e: Event) {\n        const target = e.currentTarget as HTMLElement;\n        const figcaption = target.querySelector(\"figcaption\");\n\n        if (figcaption == null) return;\n\n        if (e.composedPath().includes(figcaption)) {\n          return;\n        }\n\n        if (typeof getPos === \"function\") {\n          const { view } = editor;\n\n          const { tr } = view.state;\n\n          const captionNode = view.state.doc.nodeAt(getPos() + 1);\n          captionNode?.nodeSize;\n\n          tr.setSelection(\n            TextSelection.create(\n              view.state.doc,\n              getPos() + 1 + (captionNode?.nodeSize || 0),\n            ),\n          );\n\n          view.dispatch(tr);\n\n          // This is for raw HTML, its kinda not a huge deal...\n          // const defaultCaption = toDefaultCaption({ fileName, fileSize })\n          // if (figcaption.innerHTML === defaultCaption || figcaption.innerHTML === defaultCaption.split(\" \u00B7 \").join(\" \")) {\n          //\n          //   // view.dispatch(tr.setNodeMarkup(getPos(), null, { caption: \"\" }))\n          // }\n        }\n      }\n\n      let imgSrc: string | undefined = undefined;\n\n      if (isPreviewable && (url || src)) {\n        imgSrc = url || src;\n      }\n\n      let mouseIsDown = false;\n      let mouseTimeout: number | null = null;\n\n      // This is a very simple drag handler. This allows us to drag non-previewable nodes.\n      // https://discuss.prosemirror.net/t/dragndrop-a-drag-handle-element/4563\n      const handleMouseDown = (_e: MouseEvent) => {\n        // We need to give this a second just so we dont mess with \"click\" behavior.\n        mouseTimeout = setTimeout(() => {\n          mouseIsDown = true;\n        }, 10);\n      };\n\n      const handleMouseUp = (_e: MouseEvent) => {\n        mouseIsDown = false;\n        if (mouseTimeout) {\n          clearTimeout(mouseTimeout);\n        }\n      };\n\n      const handleMouseMove = (_e: MouseEvent) => {\n        if (mouseIsDown && typeof getPos === \"function\") {\n          const { view } = editor;\n          view.dispatch(\n            view.state.tr.setSelection(\n              NodeSelection.create(view.state.doc, getPos()),\n            ),\n          );\n        }\n      };\n\n      function removeFigure(this: HTMLElement) {\n        if (typeof getPos === \"function\") {\n          const { view } = editor;\n\n          const { tr } = view.state;\n\n          const pos = getPos();\n          tr.delete(pos, pos + 1);\n          view.dispatch(tr);\n        }\n\n        // For some reason it doesnt always delete the attachment, so this is some extra insurance.\n        const closestAttachment = this.closest(\".attachment\");\n        if (closestAttachment) {\n          closestAttachment.remove();\n        }\n      }\n\n      const template = html`\n        <figure\n          class=${figureClasses}\n          attachment-type=${this.name}\n          sgid=${ifDefined(sgid ? sgid : undefined)}\n          data-trix-content-type=${contentType}\n          data-trix-attachment=${trixAttachment}\n          data-trix-attributes=${trixAttributes}\n          @click=${handleFigureClick}\n          @mousedown=${handleMouseDown}\n          @mouseup=${handleMouseUp}\n          @mousemove=${handleMouseMove}\n        >\n          <rhino-attachment-editor\n            file-name=${fileName || \"\"}\n            file-size=${String(fileSize || 0)}\n            loading-state=${loadingState || LOADING_STATES.notStarted}\n            progress=${String(sgid || content || !fileSize ? 100 : progress)}\n            contenteditable=\"false\"\n            ?show-metadata=${isPreviewable}\n            .fileUploadErrorMessage=${this.options.fileUploadErrorMessage}\n            .removeFigure=${removeFigure}\n          >\n          </rhino-attachment-editor>\n\n          ${when(\n            content && !isPreviewable,\n            /* This is really not great. This is how Trix does it, but it feels very unsafe.\n               https://github.com/basecamp/trix/blob/fda14c5ae88a0821cf8999a53dcb3572b4172cf0/src/trix/views/attachment_view.js#L36\n            */\n            () => html`${unsafeHTML(content)}`,\n            () => html`\n              <img\n                class=${loadingState === LOADING_STATES.error\n                  ? \"rhino-upload-error\"\n                  : \"\"}\n                width=${String(width)}\n                height=${String(height)}\n                src=${ifDefined(imgSrc)}\n                contenteditable=\"false\"\n              />\n            `,\n          )}\n\n          <figcaption\n            style=\"${Boolean(content) ? \"display: none;\" : \"\"}\"\n            class=${`attachment__caption ${\n              caption ? \"attachment__caption--edited\" : \"is-empty\"\n            }`}\n            data-placeholder=${this.options.captionPlaceholder}\n            data-default-caption=${toDefaultCaption({ fileName, fileSize })}\n          ></figcaption>\n        </figure>\n      `;\n\n      // Scratch element to render into.\n      const scratch = document.createElement(\"div\");\n      render(template, scratch);\n\n      const dom = scratch.firstElementChild;\n      const contentDOM = dom?.querySelector(\"figcaption\");\n\n      let srcRevoked = false;\n\n      return {\n        dom,\n        contentDOM,\n        update(node) {\n          if (node.type.name !== \"attachment\") return false;\n\n          if (!srcRevoked && node.attrs.url) {\n            srcRevoked = true;\n\n            /** Do your part to save the environment. (Try to) prevent memory leaks. */\n            try {\n              URL.revokeObjectURL(node.attrs.src);\n            } catch (_e) {\n              /* We don't really care if this fails. We tried. */\n            }\n          }\n\n          return false;\n        },\n      };\n    };\n  },\n\n  addCommands() {\n    return {\n      setAttachmentAtCoords:\n        (\n          options: AttachmentManager | AttachmentManager[],\n          coordinates: { left: number; top: number },\n        ) =>\n        ({ view, state, tr, dispatch }) => {\n          let posAtCoords = view.posAtCoords(coordinates);\n\n          const currentSelection = state.doc.resolve(posAtCoords?.pos || 0);\n          return handleAttachment(options, currentSelection, {\n            state,\n            tr,\n            dispatch,\n          });\n        },\n      setAttachment:\n        (options: AttachmentManager | AttachmentManager[]) =>\n        ({ state, tr, dispatch }) => {\n          const currentSelection = state.doc.resolve(state.selection.anchor);\n          return handleAttachment(options, currentSelection, {\n            state,\n            tr,\n            dispatch,\n          });\n        },\n    };\n  },\n});\n\nexport const PreviewableAttachment = Attachment.extend({\n  name: \"previewable-attachment-figure\",\n  group: \"block previewableAttachmentFigure\",\n  addOptions() {\n    return {\n      ...Attachment.options,\n      previewable: true,\n    };\n  },\n\n  // We purposely override this to nothing. Because all of the extensions registered by Attachment\n  // are global, they run twice. We don't want that. for example, this causes `rhino-attachment-remove`\n  // to fire twice. No bueno.\n  addProseMirrorPlugins() {\n    return [];\n  },\n});\n\nfunction handleAttachment(\n  options: AttachmentManager | AttachmentManager[],\n  currentSelection: ResolvedPos,\n  { state, tr, dispatch }: Pick<CommandProps, \"state\" | \"tr\" | \"dispatch\">,\n) {\n  const { schema } = state;\n\n  const minSize = 0;\n  const maxSize = tr.doc.content.size;\n\n  function clamp(val: number, min: number = minSize, max: number = maxSize) {\n    if (val < min) return min;\n    if (val > max) return max;\n    return val;\n  }\n\n  // Attachments disabled, dont pass go.\n  const hasGalleriesDisabled = schema.nodes[\"attachment-gallery\"] == null;\n\n  const currentNode = state.doc.resolve(currentSelection.pos);\n  const paragraphTopNode = findParentNodeOfTypeClosestToPos(\n    currentNode,\n    schema.nodes[\"paragraph\"],\n  );\n\n  let currentGallery = findParentNodeOfTypeClosestToPos(\n    state.doc.resolve(currentSelection.pos),\n    schema.nodes[\"attachment-gallery\"],\n  );\n\n  let priorGalleryPos = null;\n\n  if (paragraphTopNode) {\n    const paragraphIsEmpty = currentSelection.parent.textContent === \"\";\n    const prevNode = state.doc.resolve(clamp(paragraphTopNode.pos - 1));\n\n    if (\n      paragraphIsEmpty &&\n      prevNode.parent.type.name === \"attachment-gallery\"\n    ) {\n      priorGalleryPos = clamp(paragraphTopNode.pos - 1);\n    }\n  }\n\n  const isInGallery = currentGallery || priorGalleryPos;\n\n  const attachments: AttachmentManager[] = Array.isArray(options)\n    ? options\n    : ([] as AttachmentManager[]).concat(options);\n\n  let allNodesPreviewable = true;\n\n  let attachmentNodes: ProseMirrorNode[] = [];\n\n  let previewableNodes: ProseMirrorNode[] = [];\n\n  attachments.forEach((attachment) => {\n    const nodeType = attachment.isPreviewable\n      ? \"previewable-attachment-figure\"\n      : \"attachment-figure\";\n\n    const figure = schema.nodes[nodeType].create(\n      attachment,\n      attachment.caption ? [schema.text(attachment.caption)] : [],\n    );\n\n    if (hasGalleriesDisabled) {\n      attachmentNodes.push(figure);\n      return;\n    }\n\n    if (!attachment.isPreviewable) {\n      allNodesPreviewable = false;\n\n      // Make a new gallery. Non-previewable nodes dont belong in galleries.\n      if (previewableNodes.length >= 1) {\n        attachmentNodes = attachmentNodes.concat(\n          schema.nodes[\"attachment-gallery\"].create({}, previewableNodes),\n        );\n        previewableNodes = [];\n      }\n\n      attachmentNodes.push(figure);\n      return;\n    }\n\n    previewableNodes.push(figure);\n  });\n\n  let end = 0;\n\n  if (currentGallery) {\n    end = currentGallery.start + currentGallery.node.nodeSize - 2;\n  } else if (priorGalleryPos != null) {\n    end = priorGalleryPos;\n  }\n\n  end = clamp(end);\n\n  if (hasGalleriesDisabled) {\n    attachmentNodes = attachmentNodes.flatMap((node) => [node]);\n    tr.insert(end, attachmentNodes.concat([schema.nodes.paragraph.create()]));\n\n    if (dispatch) dispatch(tr);\n    return true;\n  }\n\n  if (isInGallery) {\n    if (allNodesPreviewable) {\n      tr.insert(end, previewableNodes);\n    } else {\n      // Make a new gallery. Non-previewable nodes dont belong in galleries.\n      if (!hasGalleriesDisabled && previewableNodes.length >= 1) {\n        attachmentNodes = attachmentNodes.concat(\n          schema.nodes[\"attachment-gallery\"].create({}, previewableNodes),\n        );\n      }\n      tr.insert(end + 1, attachmentNodes);\n    }\n  } else {\n    const currSelection = state.selection;\n\n    // Make a new gallery. Non-previewable nodes dont belong in galleries.\n    if (!hasGalleriesDisabled && previewableNodes.length >= 1) {\n      attachmentNodes = attachmentNodes.concat(\n        schema.nodes[\"attachment-gallery\"].create({}, previewableNodes),\n      );\n    }\n\n    tr.replaceWith(currSelection.from - 1, currSelection.to, [\n      ...attachmentNodes,\n      schema.nodes.paragraph.create(),\n    ]);\n\n    selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n  }\n\n  if (dispatch) dispatch(tr);\n  return true;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIO,SAAS,wBACd,IACA,UACA,MACA;AACA,QAAM,OAAO,GAAG,MAAM,SAAS;AAE/B,MAAI,OAAO,UAAU;AACnB;AAAA,EACF;AAEA,QAAM,OAAO,GAAG,MAAM,IAAI;AAE1B,MAAI,EAAE,gBAAgB,eAAe,gBAAgB,oBAAoB;AACvE;AAAA,EACF;AAEA,QAAM,MAAM,GAAG,QAAQ,KAAK,IAAI;AAChC,MAAI,MAAM;AAEV,MAAI,QAAQ,CAAC,OAAO,KAAK,UAAU,UAAU;AAC3C,QAAI,QAAQ,GAAG;AACb,YAAM;AAAA,IACR;AAAA,EACF,CAAC;AAED,KAAG,aAAa,UAAU,KAAK,GAAG,IAAI,QAAQ,GAAG,GAAG,IAAI,CAAC;AAC3D;;;AEZO,IAAM,gBAAgB,CAC3B,UACA,SACY;AACZ,SACG,MAAM,QAAQ,QAAQ,KAAK,SAAS,QAAQ,KAAK,IAAI,IAAI,MAC1D,KAAK,SAAS;AAElB;AD6BO,IAAM,6BAA6B,CACxC,MACA,cACe;AACf,WAASA,KAAI,KAAK,OAAOA,KAAI,GAAGA,MAAK;AACnC,UAAM,OAAO,KAAK,KAAKA,EAAC;AACxB,QAAI,UAAU,IAAI,GAAG;AACnB,aAAO;QACL,KAAKA,KAAI,IAAI,KAAK,OAAOA,EAAC,IAAI;QAC9B,OAAO,KAAK,MAAMA,EAAC;QACnB,OAAOA;QACP;MACF;IACF;EACF;AACF;AA+CO,IAAM,mCAAmC,CAC9C,MACA,aACe;AACf,SAAO;IAA2B;IAAM,CAAC,SACvC,cAAc,UAAU,IAAI;EAC9B;AACF;AGjHO,IAAM,UAAU,CACrB,MACA,UAAmB,SACC;AACpB,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,0BAA0B;EAC5C;AACA,QAAM,SAA0B,CAAC;AACjC,OAAK,YAAY,CAAC,OAAO,QAAQ;AAC/B,WAAO,KAAK,EAAE,MAAM,OAAO,IAAI,CAAC;AAChC,QAAI,CAAC,SAAS;AACZ,aAAO;IACT;EACF,CAAC;AACD,SAAO;AACT;AAOO,IAAM,eAAe,CAC1B,MACA,WACA,UAAmB,SACC;AACpB,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,0BAA0B;EAC5C,WAAW,CAAC,WAAW;AACrB,UAAM,IAAI,MAAM,+BAA+B;EACjD;AACA,SAAO,QAAQ,MAAM,OAAO,EAAE,OAAO,CAAC,UAAU,UAAU,MAAM,IAAI,CAAC;AACvE;AAwDO,IAAM,qBAAqB,CAChC,MACA,UACA,UAAmB,SACC;AACpB,SAAO,aAAa,MAAM,CAAC,UAAU,MAAM,SAAS,UAAU,OAAO;AACvE;;;AClEa,IAAAC,IAAW,EACtBC,WAAW,GACXC,OAAO,GACPC,UAAU,GACVC,mBAAmB,GACnBC,OAAO,GACPC,SAAS,EAAA;AANE,IA0CAC,IACgBC,CAAAA,OAC3B,IAAIC,QAAsE,EAExEC,iBAAqBF,IACrBC,QAAAA,GAAAA;AAAAA,IAQkBE,IARlBF,MAQkBE;EAkBpBC,YAAYC,IAAAA;EAAuB;EAG/BC,IAAAA,OAAAA;AACF,WAAOC,KAAKC,KAASF;EACtB;EAGDG,KACEC,IACAC,IACAC,IAAAA;AAEAL,SAAKM,OAASH,IACdH,KAAKC,OAAWG,IAChBJ,KAAKO,OAAmBF;EACzB;EAEDG,KAAUL,IAAYM,IAAAA;AACpB,WAAOT,KAAKU,OAAOP,IAAMM,EAAAA;EAC1B;EAIDC,OAAOC,IAAaF,IAAAA;AAClB,WAAOT,KAAKY,OAAAA,GAAUH,EAAAA;EACvB;AAAA;;;ACjIG,IAAOI,KAAP,cAAmCC,EAAAA;EAOvCC,YAAYC,IAAAA;AAEV,QADAC,MAAMD,EAAAA,GAJAE,KAAMC,KAAYC,GAKpBJ,GAASK,SAASC,EAASC;AAC7B,YAAUC,MAELN,KAAKH,YAA2CU,gBADnD,uCAAA;EAKL;EAEDC,OAAOC,GAAAA;AACL,QAAIA,MAAUP,KAAoB,QAATO;AAEvB,aADAT,KAAKU,KAAAA,QACGV,KAAKC,KAASQ;AAExB,QAAIA,MAAUE;AACZ,aAAOF;AAET,QAAoB,YAAA,OAATA;AACT,YAAUH,MAELN,KAAKH,YAA2CU,gBADnD,mCAAA;AAKJ,QAAIE,MAAUT,KAAKC;AACjB,aAAOD,KAAKU;AAEdV,SAAKC,KAASQ;AACd,UAAMG,IAAU,CAACH,CAAAA;AAKjB,WAHCG,EAAgBC,MAAMD,GAGfZ,KAAKU,KAAkB,EAI7BI,YAAiBd,KAAKH,YACnBkB,YACHH,SAAAA,GACAI,QAAQ,CAAA,EAAA;EAEX;AAAA;AAlDMrB,GAAaY,gBAAG,cAChBZ,GAAUoB,aAJC;AAAA,IAkEPE,IAAaC,EAAUvB,EAAAA;;;AC7DvB,IAAAwB,IAAgBC,CAAAA,OAAaA,QAAAA,KAAAA,KAASC;;;SCwBnCC,EACdC,IACAC,IACAC,GAAAA;AAEA,SAAOF,KAAYC,GAAAA,IAAaC,QAAAA,IAAAA,SAAAA,EAAAA;AAClC;;;ACiCO,IAAM,cAAc;AAAA,EACzB;AAAA,EACA;AACF;AAOA,SAAS,4BAA4B,SAAsB;AACzD,SACE,cAAc,SAAS,cAAc,KACrC,KAAK,MAAM,QAAQ,aAAa,sBAAsB,KAAK,IAAI,EAC5D,eACH;AAEJ;AAEA,IAAM,qBAAqB,CACzB,MACA,kBACG;AACH,MAAI,gBAAgB,aAAa;AAC/B,UAAM,cAAc,4BAA4B,IAAI;AAEpD,QAAI,gBAAgB,4BAA4B;AAC9C,aAAO;AAAA,IACT;AAGA,UAAM,uBAAuB,KAAK,QAAQ,wBAAwB;AAClE,QAAI,sBAAsB;AACxB,YAAMC,eACJ,qBAAqB,aAAa,aAAa,MAAM;AAEvD,UAAI,CAAC,qBAAqB,aAAa,MAAM,GAAG;AAC9C,eAAO;AAAA,MACT;AAEA,UAAIA,iBAAgB,eAAe;AACjC,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,cAAc;AAAA,MAClB,cAAc,MAAM,aAAa;AAAA,MACjC,cAAc,MAAM,aAAa;AAAA,IACnC;AAEA,QAAI,gBAAgB,eAAe;AACjC,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AAMA,SAAS,eACP,MACA,IACA,UACA,KACA;AACA,MAAI,WAAW;AAEf,MAAI,YAAY,SAAS,KAAK,KAAK,IAAI,MAAM;AAAO,WAAO;AAG3D,MAAI,UAAU,SAAS,cAAc,KAAK;AAC1C,UAAQ;AAAA,IACN,cAAc,WAAW,SAAS,MAAM,EAAE,cAAc,IAAI;AAAA,EAC9D;AAEA,QAAM,aAAa,QAAQ,cAAc,YAAY;AAErD,MAAI,cAAc;AAAM,WAAO;AAE/B,QAAM,UAAU,WAAW;AAC3B,MAAI,KAAK,MAAM,YAAY,SAAS;AAClC,OAAG,cAAc,KAAK,QAAW;AAAA,MAC/B,GAAG,KAAK;AAAA,MACR;AAAA,IACF,CAAC;AACD,eAAW;AAAA,EACb;AAEA,SAAO;AACT;AAEA,SAAS,WAAW,aAAsB,aAAqC;AAC7E,SAAO;AAAA,IACL,eAAe,kBAAkB,cAAc,eAAe,EAAE;AAAA,EAClE;AACF;AAEA,SAAS,YAAY,UAAiC;AACpD,MAAI,CAAC;AAAU,WAAO;AAEtB,SAAO,iBAAiB,SAAS,MAAM,UAAU,IAAI,CAAC,EAAE,YAAY;AACtE;AAEA,SAAS,OAAO,SAAwB,aAA8B;AACpE,MAAI,aAAa;AACf,WAAO;AAAA,EACT;AAEA,MAAI,SAAS;AACX,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,IAAM,aAAaC,MAAK,OAA0B;AAAA,EACvD,MAAM;AAAA,EACN,OAAO;AAAA,EACP,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,WAAW;AAAA,EACX,WAAW;AAAA,EACX,UAAU;AAAA,EAEV,wBAAwB;AACtB,WAAO;AAAA,MACL,IAAI,OAAO;AAAA,QACT,KAAK,IAAI,UAAU,wBAAwB;AAAA,QAC3C,kBAAkB,eAAe,WAAW,UAAU;AACpD,gBAAM,KAAK,SAAS;AACpB,cAAI,WAAW;AAGf,mBAAS,IAAI,YAAY,CAAC,MAAM,KAAK,YAAY;AAC/C,kBAAM,YAAY,CAAC,eAAe,MAAM,IAAI,UAAU,GAAG,CAAC;AAE1D,kBAAM,eAAe,UAAU,KAAK,CAAC,SAAS,SAAS,IAAI;AAE3D,gBAAI,cAAc;AAChB,yBAAW;AAAA,YACb;AAAA,UACF,CAAC;AAED,cAAI;AAAU,mBAAO;AAErB,iBAAO;AAAA,QACT;AAAA,MACF,CAAC;AAAA,MACD,IAAI,OAAO;AAAA,QACT,KAAK,IAAI,UAAU,8CAA8C;AAAA,QACjE,OAAO;AAAA,UACL,aAAa,CAAC,MAAM,UAAU;AAC5B,kBAAM,OAAO,KAAK,MAAM,UAAU,QAAQ,OAAO,KAAK;AAEtD,kBAAM,EAAE,cAAc,IAAI;AAE1B,gBAAI,CAAC;AAAe,qBAAO;AAE3B,gBAAI,YAAY,SAAS,IAAI,GAAG;AAC9B,oBAAM,eAAe;AACrB,oBAAM,KAAK,KAAK,MAAM;AAGtB,oBAAM,OAAO,cAAc,QAAQ,YAAY;AAC/C,iBAAG,WAAW,IAAI;AAClB,mBAAK,SAAS,EAAE;AAChB,qBAAO;AAAA,YACT;AACA,mBAAO;AAAA,UACT;AAAA,UACA,eAAe,CAAC,MAAM,UAAU;AAK9B,gBAAI,CAAC,aAAa,OAAO,EAAE,SAAS,MAAM,GAAG,GAAG;AAC9C,oBAAM,OAAO,KAAK,MAAM,UAAU,MAAM,OAAO,KAAK;AACpD,oBAAM,UAAU,KAAK,MAAM,UAAU,MAAM,OAAO;AAElD,kBAAI,KAAK,MAAM,UAAU,OAAO,KAAK,MAAM,UAAU,MAAM;AACzD,uBAAO;AAAA,cACT;AAEA,kBAAI,YAAY,SAAS,IAAI,KAAK,YAAY,IAAI;AAChD,sBAAM,eAAe;AACrB,uBAAO;AAAA,cACT;AAAA,YACF;AAEA,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF,CAAC;AAAA,MACD,IAAI,OAAO;AAAA,QACT,KAAK,IAAI,UAAU,+BAA+B;AAAA,QAClD,OAAO;AAIL,gBAAM,6BAA6B,oBAAI,IAGrC;AAEF,iBAAO;AAAA,YACL,OAAO,MAAM,WAAW;AACtB,oBAAM,YAAY;AAAA,gBAChB,KAAK,MAAM,OAAO,MAAM,+BAA+B;AAAA,gBACvD,KAAK,MAAM,OAAO,MAAM,mBAAmB;AAAA,cAC7C;AAEA,wBAAU,QAAQ,CAAC,aAAa;AAC9B,sBAAM,wBAAwB;AAAA,kBAC5B,UAAU;AAAA,kBACV;AAAA,gBACF;AAGA,mCAAmB,KAAK,MAAM,KAAK,QAAQ,EAAE,QAAQ,CAAC,SAAS;AAC7D,wBAAM,YAAY,KAAK,KACpB;AACH,wBAAM,OAAO,UAAU;AACvB,wBAAM,eAAe,UAAU;AAE/B,sBAAI,MAAM;AACR,+CAA2B,IAAI,MAAM,IAAI;AAAA,kBAC3C;AAEA,sBAAI,cAAc;AAChB,+CAA2B,IAAI,cAAc,IAAI;AAAA,kBACnD;AAAA,gBACF,CAAC;AAED,sCAAsB,QAAQ,CAAC,SAAS;AACtC,wBAAM,YAAY,KAAK,KACpB;AAEH,wBAAM,EAAE,MAAM,aAAa,IAAI;AAE/B,sBAAI,QAAQ,2BAA2B,IAAI,IAAI;AAAG;AAClD,sBACE,gBACA,2BAA2B,IAAI,YAAY;AAE3C;AAEF,wBAAM,oBAAoB,IAAI;AAAA,oBAC5B;AAAA,oBACA;AAAA,kBACF;AAEA,uBAAK,IAAI;AAAA,oBACP,IAAI,sBAAsB,iBAAiB;AAAA,kBAC7C;AAAA,gBACF,CAAC;AAED,2CAA2B,MAAM;AAAA,cACnC,CAAC;AAAA,YACH;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAAA,EACA,aAAa;AACX,WAAO;AAAA,MACL,gBAAgB;AAAA,QACd,OAAO;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA,aAAa;AAAA,IACf;AAAA,EACF;AAAA,EAEA,YAAY;AACV,WAAO;AAAA;AAAA,MAEL;AAAA,QACE,KAAK;AAAA,QACL,UAAU,CAAC,SAAS;AAClB,gBAAM,UAAU,mBAAmB,MAAM,KAAK,QAAQ,WAAW;AAEjE,cAAI,CAAC,SAAS;AACZ,mBAAO;AAAA,UACT;AAEA,iBAAO;AAAA,QACT;AAAA,MACF;AAAA;AAAA,MAEA;AAAA,QACE,KAAK;AAAA,QACL,gBAAgB;AAAA,QAChB,UAAU,CAAC,SAAS;AAClB,gBAAM,UAAU,mBAAmB,MAAM,KAAK,QAAQ,WAAW;AAEjE,cAAI,CAAC,SAAS;AACZ,mBAAO;AAAA,UACT;AAEA,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,MACA;AAAA,QACE,KAAK;AAAA,QACL,UAAU,CAAC,SAAS;AAClB,gBAAM,UAAU,mBAAmB,MAAM,KAAK,QAAQ,WAAW;AAEjE,cAAI,CAAC,SAAS;AACZ,mBAAO;AAAA,UACT;AAEA,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,WAAW,EAAE,KAAK,GAAG;AACnB,UAAM;AAAA;AAAA,MAEJ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA,MAGA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI,KAAK;AAET,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU;AAAA,MACV,UAAU;AAAA,MACV;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,UAAM,SAAS;AAAA,MACb;AAAA,MACA,gBAAgB,KAAK,QAAQ,gBAAgB;AAAA,QAC3C,OACE,KAAK,QAAQ,eAAe,QAC5B,MACA,OAAO,SAAS,WAAW,aAAa,WAAW,CAAC,IACpD,MACA,YAAY,QAAQ;AAAA,QACtB,0BAA0B;AAAA,QAC1B,wBAAwB,KAAK,UAAU,eAAe;AAAA,QACtD,wBAAwB,KAAK,UAAU;AAAA,UACrC;AAAA,UACA,GAAI,WAAW,aAAa,WAAW,IACnC,EAAE,cAAc,UAAU,IAC1B,CAAC;AAAA,QACP,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAEA,UAAM,aAAa;AAAA,MACjB;AAAA,MACA;AAAA,QACE,CAAC;AAAA,QACD,EAAE,OAAO,kDAAkD;AAAA,MAC7D;AAAA,MACA;AAAA,IACF;AAEA,UAAM,QAAQ;AAAA,MACZ;AAAA,MACA;AAAA,QACE,CAAC;AAAA,QACD;AAAA,UACE,KAAK,OAAO;AAAA,UACZ,iBAAiB;AAAA,UACjB;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,WAAW,WAAW,aAAa,WAAW,GAAG;AACpD,aAAO,CAAC,GAAG,QAAQ,OAAO,UAAU;AAAA,IACtC;AAEA,WAAO,CAAC,GAAG,QAAQ,UAAU;AAAA,EAC/B;AAAA,EAEA,gBAAgB;AACd,WAAO;AAAA,MACL,cAAc,EAAE,SAAS,KAAK;AAAA,MAC9B,SAAS;AAAA,QACP,SAAS;AAAA,QACT,WAAW,CAAC,YAAY;AACtB,iBACE,QAAQ,cAAc,YAAY,GAAG,aACrC,cAAc,SAAS,SAAS;AAAA,QAEpC;AAAA,MACF;AAAA,MACA,UAAU;AAAA,QACR,SAAS;AAAA,QACT,WAAW,CAAC,YAAY;AACtB,iBAAO,cAAc,SAAS,MAAM,KAClC,cAAc,SAAS,SAAS,KAChC,QAAQ,QAAQ,wBAAwB,GAAG,YACzC,MACA;AAAA,QACN;AAAA,MACF;AAAA,MACA,cAAc;AAAA,QACZ,SAAS,eAAe;AAAA,QACxB,WAAW,CAAC,YACV,cAAc,SAAS,MAAM,IACzB,eAAe,UACf,eAAe;AAAA,MACvB;AAAA,MACA,MAAM;AAAA,QACJ,SAAS;AAAA,QACT,WAAW,CAAC,YAAY,cAAc,SAAS,MAAM;AAAA,MACvD;AAAA,MACA,KAAK;AAAA,QACH,SAAS;AAAA,QACT,WAAW,CAAC,YAAY,cAAc,SAAS,KAAK;AAAA,MACtD;AAAA,MACA,QAAQ;AAAA,QACN,SAAS;AAAA,QACT,WAAW,CAAC,YAAY,cAAc,SAAS,QAAQ;AAAA,MACzD;AAAA,MACA,OAAO;AAAA,QACL,SAAS;AAAA,QACT,WAAW,CAAC,YAAY;AACtB,iBAAO,cAAc,SAAS,OAAO;AAAA,QACvC;AAAA,MACF;AAAA,MACA,aAAa;AAAA,QACX,SAAS;AAAA,QACT,WAAW,CAAC,YAAY;AACtB,iBAAO,4BAA4B,OAAO;AAAA,QAC5C;AAAA,MACF;AAAA,MACA,UAAU;AAAA,QACR,SAAS;AAAA,QACT,WAAW,CAAC,YAAY,cAAc,SAAS,UAAU;AAAA,MAC3D;AAAA,MACA,UAAU;AAAA,QACR,SAAS;AAAA,QACT,WAAW,CAAC,YAAY,cAAc,SAAS,UAAU;AAAA,MAC3D;AAAA,MACA,SAAS;AAAA,QACP,SAAS;AAAA,QACT,WAAW,CAAC,YAAY;AACtB,gBAAM,aAAa,QAAQ,QAAQ,wBAAwB;AAE3D,cAAI,UAAU;AAEd,cAAI,YAAY;AACd,kBAAM,YAAY,IAAI,UAAU;AAChC,kBAAM,YAAY,UAAU;AAAA,cAC1B,WAAW;AAAA,cACX;AAAA,YACF;AAEA,kBAAM,aAAa,UAAU,KAAK;AAElC,gBAAI,YAAY;AACd,kBACE,WAAW,QAAQ,YAAY,MAAM,YACrC,CAAC,WAAW,UAAU,SAAS,YAAY,GAC3C;AACA,0BAAU,WAAW;AAAA,cACvB;AAAA,YACF;AAAA,UACF;AAEA,iBAAO,WAAW,cAAc,SAAS,SAAS;AAAA,QACpD;AAAA,MACF;AAAA,MACA,KAAK;AAAA,QACH,SAAS;AAAA,QACT,WAAW,CAAC,YAAY;AACtB,iBAAO,cAAc,SAAS,KAAK;AAAA,QACrC;AAAA,MACF;AAAA,MACA,aAAa;AAAA,QACX,SAAS;AAAA,QACT,WAAW,CAAC,YAAY;AACtB,cAAI,EAAE,YAAY,IAAI,KAAK;AAAA,YACzB,QAAQ,aAAa,sBAAsB,KAAK;AAAA,UAClD;AAEA,cAAI,eAAe,MAAM;AACvB,0BAAc,cAAc,SAAS,aAAa;AAAA,UACpD;AAEA,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,cAAc;AACZ,WAAO,CAAC,EAAE,MAAM,QAAQ,OAAO,MAAM;AACnC,YAAM;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,IAAI,KAAK;AAET,YAAM,iBAAiB,KAAK,UAAU;AAAA,QACpC;AAAA,QACA;AAAA,QACA,UAAU;AAAA,QACV,UAAU;AAAA,QACV;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAED,YAAM,gBAAgB,WAAW,aAAa,WAAW;AAEzD,YAAM,iBAAiB,KAAK,UAAU;AAAA,QACpC,GAAI,gBAAgB,EAAE,cAAc,UAAU,IAAI,CAAC;AAAA,QACnD;AAAA,MACF,CAAC;AAED,YAAM,gBAAgB;AAAA,UAClB,KAAK,QAAQ,eAAe,KAAK;AAAA,UACjC,OAAO,SAAS,WAAW,aAAa,WAAW,CAAC,CAAC;AAAA,UACrD,YAAY,QAAQ,CAAC;AAAA;AAGzB,eAAS,kBAAkBC,IAAU;AACnC,cAAM,SAASA,GAAE;AACjB,cAAM,aAAa,OAAO,cAAc,YAAY;AAEpD,YAAI,cAAc;AAAM;AAExB,YAAIA,GAAE,aAAa,EAAE,SAAS,UAAU,GAAG;AACzC;AAAA,QACF;AAEA,YAAI,OAAO,WAAW,YAAY;AAChC,gBAAM,EAAE,KAAK,IAAI;AAEjB,gBAAM,EAAE,GAAG,IAAI,KAAK;AAEpB,gBAAM,cAAc,KAAK,MAAM,IAAI,OAAO,OAAO,IAAI,CAAC;AACtD,uBAAa;AAEb,aAAG;AAAA,YACD,cAAc;AAAA,cACZ,KAAK,MAAM;AAAA,cACX,OAAO,IAAI,KAAK,aAAa,YAAY;AAAA,YAC3C;AAAA,UACF;AAEA,eAAK,SAAS,EAAE;AAAA,QAQlB;AAAA,MACF;AAEA,UAAI,SAA6B;AAEjC,UAAI,kBAAkB,OAAO,MAAM;AACjC,iBAAS,OAAO;AAAA,MAClB;AAEA,UAAI,cAAc;AAClB,UAAI,eAA8B;AAIlC,YAAM,kBAAkB,CAAC,OAAmB;AAE1C,uBAAe,WAAW,MAAM;AAC9B,wBAAc;AAAA,QAChB,GAAG,EAAE;AAAA,MACP;AAEA,YAAM,gBAAgB,CAAC,OAAmB;AACxC,sBAAc;AACd,YAAI,cAAc;AAChB,uBAAa,YAAY;AAAA,QAC3B;AAAA,MACF;AAEA,YAAM,kBAAkB,CAAC,OAAmB;AAC1C,YAAI,eAAe,OAAO,WAAW,YAAY;AAC/C,gBAAM,EAAE,KAAK,IAAI;AACjB,eAAK;AAAA,YACH,KAAK,MAAM,GAAG;AAAA,cACZ,cAAc,OAAO,KAAK,MAAM,KAAK,OAAO,CAAC;AAAA,YAC/C;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,eAAS,eAAgC;AACvC,YAAI,OAAO,WAAW,YAAY;AAChC,gBAAM,EAAE,KAAK,IAAI;AAEjB,gBAAM,EAAE,GAAG,IAAI,KAAK;AAEpB,gBAAM,MAAM,OAAO;AACnB,aAAG,OAAO,KAAK,MAAM,CAAC;AACtB,eAAK,SAAS,EAAE;AAAA,QAClB;AAGA,cAAM,oBAAoB,KAAK,QAAQ,aAAa;AACpD,YAAI,mBAAmB;AACrB,4BAAkB,OAAO;AAAA,QAC3B;AAAA,MACF;AAEA,YAAM,WAAW;AAAA;AAAA,kBAEL,aAAa;AAAA,4BACH,KAAK,IAAI;AAAA,iBACpB,EAAU,OAAO,OAAO,MAAS,CAAC;AAAA,mCAChB,WAAW;AAAA,iCACb,cAAc;AAAA,iCACd,cAAc;AAAA,mBAC5B,iBAAiB;AAAA,uBACb,eAAe;AAAA,qBACjB,aAAa;AAAA,uBACX,eAAe;AAAA;AAAA;AAAA,wBAGd,YAAY,EAAE;AAAA,wBACd,OAAO,YAAY,CAAC,CAAC;AAAA,4BACjB,gBAAgB,eAAe,UAAU;AAAA,uBAC9C,OAAO,QAAQ,WAAW,CAAC,WAAW,MAAM,QAAQ,CAAC;AAAA;AAAA,6BAE/C,aAAa;AAAA,sCACJ,KAAK,QAAQ,sBAAsB;AAAA,4BAC7C,YAAY;AAAA;AAAA;AAAA;AAAA,YAI5B;AAAA,QACA,WAAW,CAAC;AAAA;AAAA;AAAA;AAAA,QAIZ,MAAM,IAAO,EAAW,OAAO,CAAC;AAAA,QAChC,MAAM;AAAA;AAAA,wBAEM,iBAAiB,eAAe,QACpC,uBACA,EAAE;AAAA,wBACE,OAAO,KAAK,CAAC;AAAA,yBACZ,OAAO,MAAM,CAAC;AAAA,sBACjB,EAAU,MAAM,CAAC;AAAA;AAAA;AAAA;AAAA,MAI7B,CAAC;AAAA;AAAA;AAAA,qBAGU,QAAQ,OAAO,IAAI,mBAAmB,EAAE;AAAA,oBACzC,uBACN,UAAU,gCAAgC,UAC5C,EAAE;AAAA,+BACiB,KAAK,QAAQ,kBAAkB;AAAA,mCAC3B,iBAAiB,EAAE,UAAU,SAAS,CAAC,CAAC;AAAA;AAAA;AAAA;AAMrE,YAAM,UAAU,SAAS,cAAc,KAAK;AAC5C,QAAO,UAAU,OAAO;AAExB,YAAM,MAAM,QAAQ;AACpB,YAAM,aAAa,KAAK,cAAc,YAAY;AAElD,UAAI,aAAa;AAEjB,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA,OAAOC,OAAM;AACX,cAAIA,MAAK,KAAK,SAAS;AAAc,mBAAO;AAE5C,cAAI,CAAC,cAAcA,MAAK,MAAM,KAAK;AACjC,yBAAa;AAGb,gBAAI;AACF,kBAAI,gBAAgBA,MAAK,MAAM,GAAG;AAAA,YACpC,SAAS,IAAI;AAAA,YAEb;AAAA,UACF;AAEA,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EAEA,cAAc;AACZ,WAAO;AAAA,MACL,uBACE,CACE,SACA,gBAEF,CAAC,EAAE,MAAM,OAAO,IAAI,SAAS,MAAM;AACjC,YAAI,cAAc,KAAK,YAAY,WAAW;AAE9C,cAAM,mBAAmB,MAAM,IAAI,QAAQ,aAAa,OAAO,CAAC;AAChE,eAAO,iBAAiB,SAAS,kBAAkB;AAAA,UACjD;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MACF,eACE,CAAC,YACD,CAAC,EAAE,OAAO,IAAI,SAAS,MAAM;AAC3B,cAAM,mBAAmB,MAAM,IAAI,QAAQ,MAAM,UAAU,MAAM;AACjE,eAAO,iBAAiB,SAAS,kBAAkB;AAAA,UACjD;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACJ;AAAA,EACF;AACF,CAAC;AAEM,IAAM,wBAAwB,WAAW,OAAO;AAAA,EACrD,MAAM;AAAA,EACN,OAAO;AAAA,EACP,aAAa;AACX,WAAO;AAAA,MACL,GAAG,WAAW;AAAA,MACd,aAAa;AAAA,IACf;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,wBAAwB;AACtB,WAAO,CAAC;AAAA,EACV;AACF,CAAC;AAED,SAAS,iBACP,SACA,kBACA,EAAE,OAAO,IAAI,SAAS,GACtB;AACA,QAAM,EAAE,OAAO,IAAI;AAEnB,QAAM,UAAU;AAChB,QAAM,UAAU,GAAG,IAAI,QAAQ;AAE/B,WAAS,MAAM,KAAa,MAAc,SAAS,MAAc,SAAS;AACxE,QAAI,MAAM;AAAK,aAAO;AACtB,QAAI,MAAM;AAAK,aAAO;AACtB,WAAO;AAAA,EACT;AAGA,QAAM,uBAAuB,OAAO,MAAM,oBAAoB,KAAK;AAEnE,QAAM,cAAc,MAAM,IAAI,QAAQ,iBAAiB,GAAG;AAC1D,QAAM,mBAAmB;AAAA,IACvB;AAAA,IACA,OAAO,MAAM,WAAW;AAAA,EAC1B;AAEA,MAAI,iBAAiB;AAAA,IACnB,MAAM,IAAI,QAAQ,iBAAiB,GAAG;AAAA,IACtC,OAAO,MAAM,oBAAoB;AAAA,EACnC;AAEA,MAAI,kBAAkB;AAEtB,MAAI,kBAAkB;AACpB,UAAM,mBAAmB,iBAAiB,OAAO,gBAAgB;AACjE,UAAM,WAAW,MAAM,IAAI,QAAQ,MAAM,iBAAiB,MAAM,CAAC,CAAC;AAElE,QACE,oBACA,SAAS,OAAO,KAAK,SAAS,sBAC9B;AACA,wBAAkB,MAAM,iBAAiB,MAAM,CAAC;AAAA,IAClD;AAAA,EACF;AAEA,QAAM,cAAc,kBAAkB;AAEtC,QAAM,cAAmC,MAAM,QAAQ,OAAO,IAC1D,UACC,CAAC,EAA0B,OAAO,OAAO;AAE9C,MAAI,sBAAsB;AAE1B,MAAI,kBAAqC,CAAC;AAE1C,MAAI,mBAAsC,CAAC;AAE3C,cAAY,QAAQ,CAAC,eAAe;AAClC,UAAM,WAAW,WAAW,gBACxB,kCACA;AAEJ,UAAM,SAAS,OAAO,MAAM,QAAQ,EAAE;AAAA,MACpC;AAAA,MACA,WAAW,UAAU,CAAC,OAAO,KAAK,WAAW,OAAO,CAAC,IAAI,CAAC;AAAA,IAC5D;AAEA,QAAI,sBAAsB;AACxB,sBAAgB,KAAK,MAAM;AAC3B;AAAA,IACF;AAEA,QAAI,CAAC,WAAW,eAAe;AAC7B,4BAAsB;AAGtB,UAAI,iBAAiB,UAAU,GAAG;AAChC,0BAAkB,gBAAgB;AAAA,UAChC,OAAO,MAAM,oBAAoB,EAAE,OAAO,CAAC,GAAG,gBAAgB;AAAA,QAChE;AACA,2BAAmB,CAAC;AAAA,MACtB;AAEA,sBAAgB,KAAK,MAAM;AAC3B;AAAA,IACF;AAEA,qBAAiB,KAAK,MAAM;AAAA,EAC9B,CAAC;AAED,MAAI,MAAM;AAEV,MAAI,gBAAgB;AAClB,UAAM,eAAe,QAAQ,eAAe,KAAK,WAAW;AAAA,EAC9D,WAAW,mBAAmB,MAAM;AAClC,UAAM;AAAA,EACR;AAEA,QAAM,MAAM,GAAG;AAEf,MAAI,sBAAsB;AACxB,sBAAkB,gBAAgB,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC;AAC1D,OAAG,OAAO,KAAK,gBAAgB,OAAO,CAAC,OAAO,MAAM,UAAU,OAAO,CAAC,CAAC,CAAC;AAExE,QAAI;AAAU,eAAS,EAAE;AACzB,WAAO;AAAA,EACT;AAEA,MAAI,aAAa;AACf,QAAI,qBAAqB;AACvB,SAAG,OAAO,KAAK,gBAAgB;AAAA,IACjC,OAAO;AAEL,UAAI,CAAC,wBAAwB,iBAAiB,UAAU,GAAG;AACzD,0BAAkB,gBAAgB;AAAA,UAChC,OAAO,MAAM,oBAAoB,EAAE,OAAO,CAAC,GAAG,gBAAgB;AAAA,QAChE;AAAA,MACF;AACA,SAAG,OAAO,MAAM,GAAG,eAAe;AAAA,IACpC;AAAA,EACF,OAAO;AACL,UAAM,gBAAgB,MAAM;AAG5B,QAAI,CAAC,wBAAwB,iBAAiB,UAAU,GAAG;AACzD,wBAAkB,gBAAgB;AAAA,QAChC,OAAO,MAAM,oBAAoB,EAAE,OAAO,CAAC,GAAG,gBAAgB;AAAA,MAChE;AAAA,IACF;AAEA,OAAG,YAAY,cAAc,OAAO,GAAG,cAAc,IAAI;AAAA,MACvD,GAAG;AAAA,MACH,OAAO,MAAM,UAAU,OAAO;AAAA,IAChC,CAAC;AAED,4BAAwB,IAAI,GAAG,MAAM,SAAS,GAAG,EAAE;AAAA,EACrD;AAEA,MAAI;AAAU,aAAS,EAAE;AACzB,SAAO;AACT;",
  "names": ["i", "PartType", "ATTRIBUTE", "CHILD", "PROPERTY", "BOOLEAN_ATTRIBUTE", "EVENT", "ELEMENT", "directive", "c", "values", "_$litDirective$", "Directive", "constructor", "_partInfo", "_$isConnected", "this", "_$parent", "_$initialize", "part", "parent", "attributeIndex", "__part", "__attributeIndex", "_$resolve", "props", "update", "_part", "render", "UnsafeHTMLDirective", "Directive", "constructor", "partInfo", "super", "this", "_value", "nothing", "type", "PartType", "CHILD", "Error", "directiveName", "render", "value", "_templateResult", "noChange", "strings", "raw", "_$litType$", "resultType", "values", "unsafeHTML", "directive", "ifDefined", "value", "nothing", "when", "condition", "trueCase", "falseCase", "previewable", "Node", "e", "node"]
}
