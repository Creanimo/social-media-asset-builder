import {
  TipTapEditorBase
} from "./chunk-BXUFJHWS.js";
import {
  toolbarButtonStyles
} from "./chunk-6POPAA7L.js";
import {
  e,
  i,
  t
} from "./chunk-Z6DXFWEE.js";
import {
  getNodeType,
  objectIncludes
} from "./chunk-MF337FR6.js";
import {
  icons_exports
} from "./chunk-UUR5LFSN.js";
import {
  isiOS,
  translations
} from "./chunk-QELSW4JY.js";
import {
  A,
  i as i2,
  j,
  s,
  x
} from "./chunk-TJHM52GM.js";
import {
  __publicField
} from "./chunk-XMOP4PEQ.js";

// node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directive-helpers.js
var { I: l } = j;
var e2 = (o3) => void 0 === o3.strings;

// node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/async-directive.js
var s2 = (i3, t2) => {
  var e4, o3;
  const r2 = i3._$AN;
  if (void 0 === r2)
    return false;
  for (const i4 of r2)
    null === (o3 = (e4 = i4)._$AO) || void 0 === o3 || o3.call(e4, t2, false), s2(i4, t2);
  return true;
};
var o = (i3) => {
  let t2, e4;
  do {
    if (void 0 === (t2 = i3._$AM))
      break;
    e4 = t2._$AN, e4.delete(i3), i3 = t2;
  } while (0 === (null == e4 ? void 0 : e4.size));
};
var r = (i3) => {
  for (let t2; t2 = i3._$AM; i3 = t2) {
    let e4 = t2._$AN;
    if (void 0 === e4)
      t2._$AN = e4 = /* @__PURE__ */ new Set();
    else if (e4.has(i3))
      break;
    e4.add(i3), l2(t2);
  }
};
function n(i3) {
  void 0 !== this._$AN ? (o(this), this._$AM = i3, r(this)) : this._$AM = i3;
}
function h(i3, t2 = false, e4 = 0) {
  const r2 = this._$AH, n3 = this._$AN;
  if (void 0 !== n3 && 0 !== n3.size)
    if (t2)
      if (Array.isArray(r2))
        for (let i4 = e4; i4 < r2.length; i4++)
          s2(r2[i4], false), o(r2[i4]);
      else
        null != r2 && (s2(r2, false), o(r2));
    else
      s2(this, i3);
}
var l2 = (i3) => {
  var t2, s3, o3, r2;
  i3.type == t.CHILD && (null !== (t2 = (o3 = i3)._$AP) && void 0 !== t2 || (o3._$AP = h), null !== (s3 = (r2 = i3)._$AQ) && void 0 !== s3 || (r2._$AQ = n));
};
var c = class extends i {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i3, t2, e4) {
    super._$AT(i3, t2, e4), r(this), this.isConnected = i3._$AU;
  }
  _$AO(i3, t2 = true) {
    var e4, r2;
    i3 !== this.isConnected && (this.isConnected = i3, i3 ? null === (e4 = this.reconnected) || void 0 === e4 || e4.call(this) : null === (r2 = this.disconnected) || void 0 === r2 || r2.call(this)), t2 && (s2(this, i3), o(this));
  }
  setValue(t2) {
    if (e2(this._$Ct))
      this._$Ct._$AI(t2, this);
    else {
      const i3 = [...this._$Ct._$AH];
      i3[this._$Ci] = t2, this._$Ct._$AI(i3, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};

// node_modules/.pnpm/lit-html@2.8.0/node_modules/lit-html/directives/ref.js
var e3 = () => new o2();
var o2 = class {
};
var h2 = /* @__PURE__ */ new WeakMap();
var n2 = e(class extends c {
  render(t2) {
    return A;
  }
  update(t2, [s3]) {
    var e4;
    const o3 = s3 !== this.G;
    return o3 && void 0 !== this.G && this.ot(void 0), (o3 || this.rt !== this.lt) && (this.G = s3, this.dt = null === (e4 = t2.options) || void 0 === e4 ? void 0 : e4.host, this.ot(this.lt = t2.element)), A;
  }
  ot(i3) {
    var t2;
    if ("function" == typeof this.G) {
      const s3 = null !== (t2 = this.dt) && void 0 !== t2 ? t2 : globalThis;
      let e4 = h2.get(s3);
      void 0 === e4 && (e4 = /* @__PURE__ */ new WeakMap(), h2.set(s3, e4)), void 0 !== e4.get(this.G) && this.G.call(this.dt, void 0), e4.set(this.G, i3), void 0 !== i3 && this.G.call(this.dt, i3);
    } else
      this.G.value = i3;
  }
  get rt() {
    var i3, t2, s3;
    return "function" == typeof this.G ? null === (t2 = h2.get(null !== (i3 = this.dt) && void 0 !== i3 ? i3 : globalThis)) || void 0 === t2 ? void 0 : t2.get(this.G) : null === (s3 = this.G) || void 0 === s3 ? void 0 : s3.value;
  }
  disconnected() {
    this.rt === this.lt && this.ot(void 0);
  }
  reconnected() {
    this.ot(this.lt);
  }
});

// node_modules/.pnpm/web-component-define@2.0.11/node_modules/web-component-define/src/internal/defineable-mixin.js
function DefineableMixin(superclass) {
  var _a;
  return _a = class extends superclass {
    /**
    * @param {null | undefined | string} [name=this.baseName]
    * @param {null | undefined | CustomElementConstructor} [ctor=this]
    * @param {ElementDefinitionOptions | undefined} [options]
    */
    static define(name, ctor, options) {
      if (!name)
        name = this.baseName;
      if (!ctor)
        ctor = this;
      let registry = window.customElements;
      if (this.__registry instanceof CustomElementRegistry) {
        registry = this.__registry;
      }
      const alreadyExists = Boolean(registry.get(name));
      if (alreadyExists && this.warnOnExistingElement) {
        console.warn(`${name} has already been registered.`);
      }
      if (!alreadyExists && ctor) {
        registry.define(name, class extends ctor {
        }, options);
      }
    }
  }, /**
   * The tag name to register your custom element under.
   * @type {string}
   */
  __publicField(_a, "baseName", ""), /**
   * Emits a console warning if the name for an element is already taken.
   * @type {boolean}
   */
  __publicField(_a, "warnOnExistingElement", false), _a;
}
var DefineableElement = class extends DefineableMixin(HTMLElement) {
};

// node_modules/.pnpm/@open-wc+dedupe-mixin@1.4.0/node_modules/@open-wc/dedupe-mixin/src/dedupeMixin.js
var appliedClassMixins = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins.set(mixedClass, mixin);
    return mixedClass;
  };
}

// node_modules/.pnpm/web-component-define@2.0.11/node_modules/web-component-define/src/internal/scoped-elements-mixin.js
var supportsScopedRegistry = !!ShadowRoot.prototype.createElement;
var ScopedElementsMixinImplementation = (superclass) => {
  var _a;
  return _a = class extends superclass {
    /**
     * Obtains the scoped elements definitions map if specified.
     *
     * @returns {ScopedElementsMap}
     */
    static get scopedElements() {
      return {};
    }
    /**
     * Obtains the ShadowRoot options.
     *
     * @type {ShadowRootInit}
     */
    static get shadowRootOptions() {
      return this.__shadowRootOptions || { mode: "open" };
    }
    /**
     * Set the shadowRoot options.
     *
     * @param {ShadowRootInit} value
     */
    static set shadowRootOptions(value) {
      this.__shadowRootOptions = value;
    }
    /**
     * @param {any[]} args
     */
    constructor(...args) {
      super(...args);
      this.renderOptions = this.renderOptions || void 0;
    }
    /**
     * Obtains the CustomElementRegistry associated to the ShadowRoot.
     *
     * @returns {CustomElementRegistry}
     */
    get registry() {
      const constructor = this.constructor;
      return constructor.__registry;
    }
    /**
     * Set the CustomElementRegistry associated to the ShadowRoot
     *
     * @param {CustomElementRegistry} registry
     */
    set registry(registry) {
      const constructor = this.constructor;
      constructor.__registry = registry;
    }
    createRenderRoot() {
      const constructor = this.constructor;
      const { scopedElements, shadowRootOptions } = constructor;
      const shouldCreateRegistry = !this.registry || this.registry === constructor.__registry && !Object.prototype.hasOwnProperty.call(this.constructor, "__registry");
      if (shouldCreateRegistry) {
        this.registry = supportsScopedRegistry ? new CustomElementRegistry() : customElements;
        for (const [tagName, klass] of Object.entries(scopedElements)) {
          this.defineScopedElement(tagName, klass);
        }
      }
      const options = {
        // @ts-expect-error multiple assignment. Sue me.
        mode: "open",
        ...shadowRootOptions,
        customElements: this.registry
      };
      const createdRoot = this.attachShadow(options);
      if (supportsScopedRegistry) {
        this.renderOptions.creationScope = createdRoot;
      }
      if (createdRoot instanceof ShadowRoot) {
        this.adoptStyles(createdRoot);
      }
      return createdRoot;
    }
    /**
     * @param {string} tagName
     */
    createScopedElement(tagName) {
      const root = supportsScopedRegistry ? this.shadowRoot : document;
      return root.createElement(tagName);
    }
    /**
     * Hook for attaching constructable stylesheets to a render root.
     * Used in the {LitScopedElementsMixin} .
     * @param {ShadowRoot} _shadowRoot
     * @returns {void}
     */
    adoptStyles(_shadowRoot) {
    }
    /**
     * Defines a scoped element.
     *
     * @param {string} tagName
     * @param {typeof HTMLElement} klass
     */
    defineScopedElement(tagName, klass) {
      const registeredClass = this.registry.get(tagName);
      if (registeredClass && supportsScopedRegistry === false && registeredClass !== klass) {
        console.error(
          [
            `You are trying to re-register the "${tagName}" custom element with a different class via ScopedElementsMixin.`,
            "This is only possible with a CustomElementRegistry.",
            "Your browser does not support this feature so you will need to load a polyfill for it.",
            'Load "@webcomponents/scoped-custom-element-registry" before you register ANY web component to the global customElements registry.',
            'e.g. add "<script src="/node_modules/@webcomponents/scoped-custom-element-registry/scoped-custom-element-registry.min.js"><\/script>" as your first script tag.',
            "For more details you can visit https://open-wc.org/docs/development/scoped-elements/"
          ].join("\n")
        );
      }
      if (!registeredClass) {
        return this.registry.define(tagName, klass);
      }
      return this.registry.get(tagName);
    }
  }, /**
   * @protected
   * @type {CustomElementRegistry}
   */
  __publicField(_a, "__registry", window.customElements), _a;
};
var ScopedElementsMixin = dedupeMixin(ScopedElementsMixinImplementation);

// node_modules/.pnpm/web-component-define@2.0.11/node_modules/web-component-define/src/internal/create-render-root-mixin.js
var CreateRenderRootMixinImplementation = (superclass) => {
  return class CreateRenderRootHost extends superclass {
    /**
     * Obtains the ShadowRoot options.
     *
     * @type {ShadowRootInit}
     */
    static get shadowRootOptions() {
      return this.__shadowRootOptions || { mode: "open" };
    }
    /**
     * Set the shadowRoot options.
     *
     * @param {ShadowRootInit} value
     */
    static set shadowRootOptions(value) {
      this.__shadowRootOptions = value;
    }
    /** @type {ShadowRootInit} */
    get shadowRootOptions() {
      return this.constructor.shadowRootOptions;
    }
    createRenderRoot() {
      const renderRoot = this.shadowRoot ?? this.attachShadow(this.shadowRootOptions || { mode: "open" });
      return renderRoot;
    }
    connectedCallback() {
      if (typeof super.connectedCallback === "function") {
        super.connectedCallback();
      }
      if (this.renderRoot == null) {
        this.renderRoot = this.createRenderRoot();
      }
    }
  };
};
var CreateRenderRootMixin = dedupeMixin(CreateRenderRootMixinImplementation);

// node_modules/.pnpm/role-components@2.0.2/node_modules/role-components/exports/base-element.js
var BaseElement = class extends DefineableMixin(s) {
};

// node_modules/.pnpm/role-components@2.0.2/node_modules/role-components/exports/toolbar/toolbar.js
var RoleToolbar = class extends BaseElement {
  constructor() {
    super();
    /** @param {Event} event */
    __publicField(this, "handleClick", (event) => {
      const focusedElement = event.composedPath().find((el) => {
        const role = el?.getAttribute?.("data-role") || "";
        return role.includes("toolbar-item");
      });
      if (focusedElement) {
        this._toolbarItems.forEach((el, index) => {
          if (el === focusedElement) {
            this._currentFocusIndex = index;
            return;
          }
          el.setAttribute("tabindex", "-1");
        });
        this.setTabIndex({ focus: false });
      } else {
        this.setTabIndex({ focus: true });
      }
    });
    /** @param {KeyboardEvent} event */
    __publicField(this, "handleKeyDown", (event) => {
      const key = event.key?.toLowerCase();
      if (this.orientation === "vertical" && (key === "arrowleft" || key === "arrowright"))
        return;
      if (this.orientation === "horizontal" && (key === "arrowdown" || key === "arrowup"))
        return;
      if (Object.keys(this.keydownHandlers).includes(key)) {
        event.preventDefault();
        this.keydownHandlers[key](event);
      }
    });
    /** @param {Event} _event */
    __publicField(this, "focusNext", (_event) => {
      this.currentFocusElement?.setAttribute("tabindex", "-1");
      this._currentFocusIndex += 1;
      if (this._currentFocusIndex >= this._toolbarItems.length) {
        this.focusFirst();
        return;
      }
      this.setTabIndex();
    });
    /** @param {Event} _event */
    __publicField(this, "focusPrevious", (_event) => {
      this.currentFocusElement?.setAttribute("tabindex", "-1");
      this._currentFocusIndex -= 1;
      if (this._currentFocusIndex < 0) {
        this.focusLast();
        return;
      }
      this.setTabIndex();
    });
    __publicField(this, "focusFirst", () => {
      this._currentFocusIndex = 0;
      this.setTabIndex();
    });
    __publicField(this, "focusLast", () => {
      if (this._toolbarItems == null)
        return;
      this._currentFocusIndex = this._toolbarItems.length - 1;
      this.setTabIndex();
    });
    __publicField(this, "setTabIndex", ({ focus = true } = {}) => {
      this.currentFocusElement?.setAttribute("tabindex", "0");
      if (focus) {
        this.currentFocusElement?.focus?.();
      }
    });
    /**
     * @param {undefined | null | Event} [evt] - triggered by a slot change event.
     */
    __publicField(this, "updateToolbarItems", (evt) => {
      const slot = evt?.target || this.shadowRoot.querySelector("slot");
      if (slot == null)
        return;
      const items = slot.assignedElements({ flatten: true }).filter((el) => {
        return el instanceof HTMLElement && el.dataset.role?.match(/toolbar-item/);
      });
      this._toolbarItems = items;
      this._currentFocusIndex = this._toolbarItems.findIndex(
        (el) => el.getAttribute("tabindex") === "0"
      );
      this._toolbarItems.forEach((el) => {
        if (this._toolbarItems[this._currentFocusIndex] === el)
          return;
        el.setAttribute("tabindex", "-1");
      });
      if (this._currentFocusIndex === -1) {
        this._currentFocusIndex = 0;
        this.currentFocusElement?.setAttribute("tabindex", "0");
      }
    });
    this._currentFocusIndex = 0;
    this.orientation = "horizontal";
    this._toolbarItems = [];
    this.addEventListener("click", this.handleClick);
    this.addEventListener("keydown", this.handleKeyDown);
    this.addEventListener("focus", this.handleClick);
  }
  /**
   * @param {import("lit").PropertyValues<this>} changedProperties
   */
  willUpdate(changedProperties) {
    if (changedProperties.has("_toolbarItems")) {
      this.updateToolbarItems();
    }
    super.willUpdate(changedProperties);
  }
  /** @returns {string} */
  static get baseName() {
    return "role-toolbar";
  }
  static get styles() {
    return i2`
      :host {
        display: block;
      }

      .base {
        display: flex;
        max-width: 100%;
        padding: 0.4rem 0.6rem;
        border-radius: 4px;
        border: 2px solid transparent;
        gap: 4px;
        overflow: auto;
      }

      :host([orientation="vertical"]) .base {
        flex-direction: column;
      }

      :host(:focus-within) .base {
        border-color: #005a9c;
      }
    `;
  }
  /**
   * @return {Record<string, (event: Event) => void>}
   */
  get keydownHandlers() {
    if (this._keydownHandlers)
      return this._keydownHandlers;
    this._keydownHandlers = {
      arrowleft: this.focusPrevious,
      arrowup: this.focusPrevious,
      arrowright: this.focusNext,
      arrowdown: this.focusNext,
      home: this.focusFirst,
      end: this.focusLast
    };
    return this._keydownHandlers;
  }
  render() {
    return x`
      <div role="toolbar" class="base" part="base">
        <slot @slotchange=${this.updateToolbarItems}></slot>
      </div>
    `;
  }
  get currentFocusElement() {
    if (this._toolbarItems == null)
      return;
    return this._toolbarItems[this._currentFocusIndex];
  }
};
__publicField(RoleToolbar, "properties", {
  orientation: { reflect: true },
  _currentFocusIndex: { state: true },
  _toolbarItems: { state: true }
});

// node_modules/.pnpm/@floating-ui+utils@0.1.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

// node_modules/.pnpm/@floating-ui+core@1.4.1/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i3 = 0; i3 < validMiddleware.length; i3++) {
    const {
      name,
      fn
    } = validMiddleware[i3];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i3 = -1;
      continue;
    }
  }
  return {
    x: x2,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x: x2,
    y
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y,
      placement,
      rects,
      platform: platform2,
      elements
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? min$1 - center : max2 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 + alignmentOffset
      }
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      const {
        x: x2,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      return {
        x: x2 + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y2
            } = _ref;
            return {
              x: x3,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y
        }
      };
    }
  };
};

// node_modules/.pnpm/@floating-ui+utils@0.1.1/node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css = getComputedStyle(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}

// node_modules/.pnpm/@floating-ui+dom@1.5.1/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x: x2,
    y
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var getElementRects = async function(_ref) {
  let {
    reference,
    floating,
    strategy
  } = _ref;
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  return {
    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
    floating: {
      x: 0,
      y: 0,
      ...await getDimensionsFn(floating)
    }
  };
};
function isRTL(element) {
  return getComputedStyle(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e4) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/.pnpm/role-components@2.0.2/node_modules/role-components/exports/tooltip/tooltip.js
var RoleTooltip = class extends BaseElement {
  constructor() {
    super();
    /**
     * @param {Event|Element} eventOrElement
     * @returns {void}
     */
    __publicField(this, "show", (eventOrElement) => {
      if (eventOrElement instanceof Event && eventOrElement.currentTarget instanceof Element) {
        eventOrElement = eventOrElement.currentTarget;
      }
      const target = eventOrElement;
      this.willShow = true;
      this.computeTooltipPosition(target);
    });
    /**
     * @param {Event} [_event]
     * @returns {void}
     */
    __publicField(this, "hide", (_event) => {
      this.willShow = false;
      this.cleanup?.();
      window.requestAnimationFrame(() => {
        if (this.willShow === true)
          return;
        const base = this.base;
        if (!base)
          return;
        base.style.display = "none";
      });
    });
    /**
     * @param {Event | KeyboardEvent} event
     */
    __publicField(this, "keyboardHide", (event) => {
      if (!("key" in event)) {
        return;
      }
      if (event.key != null && event.key.toLowerCase() === "escape") {
        event.preventDefault();
        this.hide();
      }
    });
    if (window.process == null)
      window.process = {};
    if (window.process.env == null)
      window.process.env = "development";
    this.tooltipAnchors = [];
    this._rootElement = void 0;
    this.role = "tooltip";
    this.inert = true;
    this.placement = "top";
    this.listeners = [
      ["pointerenter", this.show],
      ["pointerleave", this.hide],
      ["pointercancel", this.hide],
      ["pointerup", this.hide],
      ["focusin", this.show],
      ["focusout", this.hide],
      ["keydown", this.keyboardHide]
    ];
  }
  static get properties() {
    return {
      id: { reflect: true },
      tooltipAnchors: { state: true },
      rootElement: { state: true },
      role: { reflect: true },
      inert: { reflect: true, type: Boolean },
      placement: { reflect: true }
    };
  }
  /** @returns {string} */
  static get baseName() {
    return "role-tooltip";
  }
  static get styles() {
    return i2`
      :host {
        --background-color: #222;
        --arrow-size: 8px;
      }

      .base {
        display: none;
        position: absolute;
        left: 0px;
        top: 0px;
        max-width: calc(100vw - 10px);
        padding: 0.4em 0.6em;
        background: var(--background-color);
        color: white;
        border-radius: 4px;
        font-size: 0.9em;
        pointer-events: none;
        z-index: 1;
      }

      :host([hoist]) .base {
        position: fixed;
      }

      .arrow {
        position: absolute;
        background: var(--background-color);
        width: var(--arrow-size);
        height: var(--arrow-size);
        transform: rotate(45deg);
      }
    `;
  }
  connectedCallback() {
    super.connectedCallback();
    this.updateAnchors();
    this.attachListeners();
  }
  updateAnchors() {
    if (this.rootElement) {
      this.tooltipAnchors = Array.from(this.rootElement.querySelectorAll(this.query)) || [];
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.removeListeners();
  }
  /**
   * @type {string}
   */
  get query() {
    return `[aria-describedby~='${this.id}']`;
  }
  /** @returns {ShadowRoot | Document | undefined} */
  get rootElement() {
    if (this._rootElement == null) {
      const oldVal = this._rootElement;
      this._rootElement = this.getRootNode() || document;
      this.requestUpdate("rootElement", oldVal);
    }
    return this._rootElement;
  }
  /** @returns {void} */
  set rootElement(newVal) {
    const oldVal = this._rootElement;
    this._rootElement = newVal;
    this.requestUpdate("rootElement", oldVal);
  }
  render() {
    return x`
      <div part="base" class="base">
        <slot></slot>
        <div class="arrow" part="arrow"></div>
      </div>
    `;
  }
  /**
   * @param {Parameters<import("lit").LitElement["update"]>} args
   * @return {ReturnType<import("lit").LitElement["update"]>}
   */
  update(...args) {
    const [changedProperties] = args;
    const shouldUpdateProperties = ["id", "tooltipAnchors", "rootElement"];
    const shouldReattachListeners = shouldUpdateProperties.some((str) => changedProperties.has(str));
    if (shouldReattachListeners) {
      this.attachListeners();
    }
    super.update(...args);
  }
  /**
   * Used for re-initialized event listeners
   * @returns {void}
   */
  attachListeners() {
    this.listeners.forEach(([event, listener]) => {
      this.tooltipAnchors.forEach(
        (el) => el.removeEventListener(event, listener)
      );
      this.tooltipAnchors.forEach((el) => el.addEventListener(event, listener));
    });
  }
  /**
   * Used for cleaning up
   * @returns {void}
   */
  removeListeners() {
    this.listeners.forEach(([event, listener]) => {
      this.tooltipAnchors.forEach(
        (el) => el.removeEventListener(event, listener)
      );
    });
  }
  /** @returns {HTMLElement | undefined | null} */
  get arrow() {
    return this.shadowRoot?.querySelector(".arrow");
  }
  /**
   * @param {Element} target
   * @returns {void}
   */
  computeTooltipPosition(target) {
    const arrowEl = this.arrow;
    const base = this.base;
    if (base == null)
      return;
    if (arrowEl == null)
      return;
    base.style.display = "unset";
    const placement = this.placement || "top";
    this.cleanup = autoUpdate(target, base, () => {
      computePosition2(target, base, {
        placement,
        middleware: [
          offset(6),
          flip(),
          shift({ padding: 5 }),
          arrow({ element: arrowEl })
        ],
        strategy: this.hasAttribute("hoist") ? "fixed" : "absolute"
      }).then(({ x: x2, y, middlewareData, placement: placement2 }) => {
        Object.assign(base.style, {
          left: `${x2}px`,
          top: `${y}px`
        });
        const arrowX = middlewareData.arrow?.x;
        const arrowY = middlewareData.arrow?.y;
        const staticSide = {
          top: "bottom",
          right: "left",
          bottom: "top",
          left: "right"
        }[placement2.split("-")[0]] || "top";
        Object.assign(arrowEl.style, {
          left: arrowX != null ? `${arrowX}px` : "",
          top: arrowY != null ? `${arrowY}px` : "",
          right: "",
          bottom: "",
          [staticSide]: "-4px"
        });
      });
    });
  }
  /**
   * @return {HTMLElement | null | undefined}
   */
  get base() {
    return this.shadowRoot?.querySelector(".base");
  }
};

// src/internal/string-map.ts
function stringMap(obj) {
  let string = "";
  for (const [key, value] of Object.entries(obj)) {
    if (value) {
      string += `${key} `;
    }
  }
  return string;
}

// src/internal/is-exact-node-active.ts
function isExactNodeActive(state, typeOrName, attributes = {}) {
  const { from, to, empty } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from, to, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from;
  const matchedNodeRanges = nodeRanges.slice(-3).filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter(
    (nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false })
  );
  if (empty) {
    return !!matchedNodeRanges.length;
  }
  const range = matchedNodeRanges.reduce(
    (sum, nodeRange) => sum + nodeRange.to - nodeRange.from,
    0
  );
  return range >= selectionRange;
}

// src/exports/elements/tip-tap-editor.ts
var TipTapEditor = class extends TipTapEditorBase {
  constructor() {
    super();
    /**
     * Translations for various aspects of the editor.
     */
    this.translations = translations;
    /**
     * The <input> for inserting links
     */
    this.linkInputRef = e3();
    /**
     * The dialog that contains the link input + link / unlink buttons
     */
    this.linkDialogExpanded = false;
    this.__invalidLink__ = false;
    /** Closes the dialog for link previews */
    this.handleKeyboardDialogToggle = (e4) => {
      let { key, metaKey, ctrlKey } = e4;
      if (key == null)
        return;
      key = key.toLowerCase();
      if (key === "escape" && this.linkDialogExpanded) {
        this.closeLinkDialog();
        return;
      }
      const shortcutModifier = isiOS ? metaKey : ctrlKey;
      if (key === "k" && shortcutModifier) {
        this.showLinkDialog();
      }
    };
    /**
     * @private
     */
    this.__handleLinkDialogClick = (e4) => {
      const linkDialogContainer = this.shadowRoot?.querySelector(
        ".link-dialog__container"
      );
      if (!linkDialogContainer) {
        this.linkDialogExpanded = false;
        return;
      }
      const composedPath = e4.composedPath();
      const linkButton = this.shadowRoot?.querySelector("[name='link-button']");
      if (composedPath.includes(linkDialogContainer)) {
        return;
      }
      if (linkButton && composedPath.includes(linkButton)) {
        return;
      }
      this.linkDialogExpanded = false;
    };
    this.starterKitOptions = Object.assign(this.starterKitOptions, {
      rhinoPlaceholder: {
        placeholder: this.translations.placeholder
      },
      rhinoAttachment: {
        fileUploadErrorMessage: this.translations.fileUploadErrorMessage,
        captionPlaceholder: this.translations.captionPlaceholder
      }
    });
    this.addEventListener("keydown", this.handleKeyboardDialogToggle);
  }
  static get styles() {
    return TipTapEditorBase.styles.concat([toolbarButtonStyles]);
  }
  static get properties() {
    return Object.assign(TipTapEditorBase.properties, {
      linkDialogExpanded: { type: Boolean },
      linkInputRef: { state: true },
      translations: { state: true },
      __invalidLink__: { state: true, type: Boolean }
    });
  }
  /**
   * @override
   */
  registerDependencies() {
    super.registerDependencies();
    [RoleToolbar, RoleTooltip].forEach((el) => el.define());
  }
  updated(changedProperties) {
    if (!this.hasInitialized) {
      return super.updated(changedProperties);
    }
    if (changedProperties.has("translations")) {
      const { rhinoAttachment, rhinoPlaceholder } = this.starterKitOptions;
      if (rhinoPlaceholder) {
        rhinoPlaceholder.placeholder = this.translations.placeholder;
      }
      if (rhinoAttachment) {
        rhinoAttachment.captionPlaceholder = this.translations.captionPlaceholder;
        rhinoAttachment.fileUploadErrorMessage = this.translations.fileUploadErrorMessage;
      }
    }
    return super.updated(changedProperties);
  }
  /**
   * @override
   */
  async connectedCallback() {
    super.connectedCallback();
    await this.updateComplete;
    if (this.editor) {
      this.editor.on("focus", this.closeLinkDialog);
    }
    document.addEventListener("click", this.__handleLinkDialogClick);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("click", this.__handleLinkDialogClick);
  }
  get icons() {
    return icons_exports;
  }
  toggleLinkDialog() {
    if (this.linkDialogExpanded) {
      this.closeLinkDialog();
      return;
    }
    this.showLinkDialog();
  }
  closeLinkDialog() {
    if (this.linkDialog == null)
      return;
    this.linkDialogExpanded = false;
  }
  showLinkDialog() {
    if (this.linkDialog == null)
      return;
    const inputElement = this.linkInputRef.value;
    if (inputElement != null) {
      inputElement.value = "";
    }
    this.__invalidLink__ = false;
    this.linkDialogExpanded = true;
    setTimeout(() => {
      if (inputElement != null)
        inputElement.focus();
    });
  }
  get linkDialog() {
    return this.shadowRoot?.querySelector("#link-dialog");
  }
  attachFiles() {
    const input = this.fileInputEl;
    if (input == null)
      return;
    input.click();
  }
  addLink() {
    const inputElement = this.linkInputRef.value;
    if (inputElement == null)
      return;
    const href = inputElement.value;
    try {
      new URL(href);
      inputElement.setCustomValidity("");
      this.__invalidLink__ = false;
    } catch (error) {
      inputElement.setCustomValidity("Not a valid URL");
      this.__invalidLink__ = true;
      return;
    }
    if (href) {
      this.closeLinkDialog();
      inputElement.value = "";
      const chain = this.editor?.chain().extendMarkRange("link").setLink({ href });
      if (chain && this.editor?.state.selection.empty) {
        chain.insertContent(href);
      }
      if (chain) {
        chain.run();
      }
    }
  }
  get fileInputEl() {
    return this.shadowRoot?.getElementById(
      "file-input"
    );
  }
  async handleFileUpload() {
    const input = this.fileInputEl;
    if (input == null)
      return;
    if (input.files == null)
      return;
    const attachments = await this.handleFiles(input.files);
    if (attachments.length > 0) {
      this.editor?.chain().focus().setAttachment(attachments).run();
    }
    input.value = "";
  }
  get __tooltipExportParts() {
    return "base:toolbar__tooltip__base, arrow:toolbar__tooltip__arrow";
  }
  renderBoldButton() {
    const boldEnabled = Boolean(this.editor?.commands.toggleBold);
    if (!boldEnabled)
      return x``;
    const isDisabled = this.editor == null || !this.editor.can().toggleBold();
    const isActive = Boolean(this.editor?.isActive("bold"));
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        type="button"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--bold": true,
      "toolbar__button--active": isActive,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="bold"
        aria-disabled=${isDisabled}
        aria-pressed=${isActive}
        data-role="toolbar-item"
        @click=${async (e4) => {
      if (elementDisabled(e4.currentTarget))
        return;
      this.editor?.chain().focus().toggleBold().run();
    }}
      >
        <slot name="bold-tooltip">
          <role-tooltip
            id="bold"
            hoist
            part="toolbar__tooltip toolbar__tooltip--bold"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.bold}
          </role-tooltip>
        </slot>
        <slot name="bold-icon">${this.icons.bold}</slot>
      </button>
    `;
  }
  renderItalicButton() {
    const italicEnabled = Boolean(this.editor?.commands.toggleItalic);
    if (!italicEnabled)
      return x``;
    const isActive = Boolean(this.editor?.isActive("italic"));
    const isDisabled = this.editor == null || !this.editor.can().toggleItalic();
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        tabindex="-1"
        type="button"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--italic": true,
      "toolbar__button--active": isActive,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="italics"
        aria-disabled=${isDisabled}
        aria-pressed=${isActive}
        data-role="toolbar-item"
        @click=${(e4) => {
      if (elementDisabled(e4.currentTarget)) {
        return;
      }
      this.editor?.chain().focus().toggleItalic().run();
    }}
      >
        <slot name="italics-tooltip">
          <role-tooltip
            id="italics"
            hoist
            part="toolbar__tooltip toolbar__tooltip--italics"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.italics}
          </role-tooltip>
        </slot>
        <slot name="italics-icon"> ${this.icons.italics} </slot>
      </button>
    `;
  }
  renderStrikeButton() {
    const strikeEnabled = Boolean(this.editor?.commands.toggleStrike);
    if (!strikeEnabled)
      return x``;
    const isActive = Boolean(this.editor?.isActive("rhino-strike"));
    const isDisabled = this.editor == null || !this.editor.can().toggleStrike();
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        type="button"
        tabindex="-1"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--strike": true,
      "toolbar__button--active": isActive,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="strike"
        aria-disabled=${isDisabled}
        aria-pressed=${isActive}
        data-role="toolbar-item"
        @click=${(e4) => {
      if (elementDisabled(e4.currentTarget)) {
        return;
      }
      this.editor?.chain().focus().toggleStrike().run();
    }}
      >
        <slot name="strike-tooltip">
          <role-tooltip
            id="strike"
            hoist
            part="toolbar__tooltip toolbar__tooltip--strike"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.strike}
          </role-tooltip>
        </slot>
        <slot name="strike-icon">${this.icons.strike}</slot>
      </button>
    `;
  }
  renderLinkButton() {
    const linkEnabled = Boolean(this.editor?.commands.setLink);
    if (!linkEnabled)
      return x``;
    const isActive = Boolean(this.linkDialogExpanded);
    const isDisabled = this.editor == null || !this.editor.can().setLink({ href: "" });
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        type="button"
        tabindex="-1"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--link": true,
      "toolbar__button--active": isActive,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="link"
        aria-disabled=${isDisabled}
        aria-pressed=${isActive}
        aria-controls="link-dialog"
        data-role="toolbar-item"
        @click=${(e4) => {
      if (this.editor == null)
        return;
      if (elementDisabled(e4.currentTarget))
        return;
      this.toggleLinkDialog();
    }}
      >
        <slot name="link-tooltip">
          <role-tooltip
            id="link"
            hoist
            part="toolbar__tooltip toolbar__tooltip--link"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.link}
          </role-tooltip>
        </slot>
        <slot name="link-icon">${this.icons.link}</slot>
      </button>
    `;
  }
  renderHeadingButton() {
    const headingEnabled = Boolean(this.editor?.commands.toggleHeading);
    if (!headingEnabled)
      return x``;
    const isActive = Boolean(this.editor?.isActive("heading"));
    const isDisabled = this.editor == null || !this.editor.can().toggleHeading({ level: 1 });
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        type="button"
        tabindex="-1"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--heading": true,
      "toolbar__button--active": isActive,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="heading"
        aria-disabled=${isDisabled}
        aria-pressed=${isActive}
        data-role="toolbar-item"
        @click=${(e4) => {
      if (elementDisabled(e4.currentTarget)) {
        return;
      }
      this.editor?.chain().focus().toggleHeading({ level: 1 }).run();
    }}
      >
        <slot name="heading-tooltip">
          <role-tooltip
            id="heading"
            hoist
            part="toolbar__tooltip toolbar__tooltip--heading"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.heading}
          </role-tooltip>
        </slot>
        <slot name="heading-icon">${this.icons.heading}</slot>
      </button>
    `;
  }
  renderBlockquoteButton() {
    const blockQuoteEnabled = Boolean(this.editor?.commands.toggleBlockquote);
    if (!blockQuoteEnabled)
      return x``;
    const isActive = Boolean(this.editor?.isActive("blockquote"));
    const isDisabled = this.editor == null || !this.editor.can().toggleBlockquote();
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        type="button"
        tabindex="-1"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--blockquote": true,
      "toolbar__button--active": isActive,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="blockquote"
        aria-disabled=${isDisabled}
        aria-pressed=${isActive}
        data-role="toolbar-item"
        @click=${(e4) => {
      if (elementDisabled(e4.currentTarget)) {
        return;
      }
      this.editor?.chain().focus().toggleBlockquote().run();
    }}
      >
        <slot name="blockquote-tooltip">
          <role-tooltip
            id="blockquote"
            hoist
            part="toolbar__tooltip toolbar__tooltip--blockquote"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.blockQuote}
          </role-tooltip>
        </slot>
        <slot name="blockquote-icon">${this.icons.blockQuote}</slot>
      </button>
    `;
  }
  renderCodeBlockButton() {
    const codeBlockEnabled = Boolean(this.editor?.commands.toggleCodeBlock);
    if (!codeBlockEnabled)
      return x``;
    const isActive = Boolean(this.editor?.isActive("codeBlock"));
    const isDisabled = this.editor == null || !this.editor.can().toggleCodeBlock();
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        type="button"
        tabindex="-1"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--code-block": true,
      "toolbar__button--active": isActive,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="code-block"
        aria-disabled=${isDisabled}
        aria-pressed=${isActive}
        data-role="toolbar-item"
        @click=${(e4) => {
      if (elementDisabled(e4.currentTarget)) {
        return;
      }
      this.editor?.chain().focus().toggleCodeBlock().run();
    }}
      >
        <slot name="code-block-tooltip">
          <role-tooltip
            id="code-block"
            hoist
            part="toolbar__tooltip toolbar__tooltip--code-block"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.codeBlock}
          </role-tooltip>
        </slot>
        <slot name="code-block-icon">${this.icons.codeBlock}</slot>
      </button>
    `;
  }
  renderBulletListButton() {
    const bulletListEnabled = Boolean(this.editor?.commands.toggleBulletList);
    if (!bulletListEnabled)
      return x``;
    const isDisabled = this.editor == null || !(this.editor.can().toggleOrderedList?.() || this.editor.can().toggleBulletList());
    const isActive = Boolean(
      this.editor != null && isExactNodeActive(this.editor.state, "bulletList")
    );
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        type="button"
        tabindex="-1"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--bullet-list": true,
      "toolbar__button--active": isActive,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="bullet-list"
        aria-disabled=${isDisabled}
        aria-pressed=${isActive}
        data-role="toolbar-item"
        @click=${(e4) => {
      if (elementDisabled(e4.currentTarget)) {
        return;
      }
      this.editor?.chain().focus().toggleBulletList().run();
    }}
      >
        <slot name="bullet-list-tooltip">
          <role-tooltip
            id="bullet-list"
            hoist
            part="toolbar__tooltip toolbar__tooltip--bullet-list"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.bulletList}
          </role-tooltip>
        </slot>
        <slot name="bullet-list-icon">${this.icons.bulletList}</slot>
      </button>
    `;
  }
  renderOrderedListButton() {
    const orderedListEnabled = Boolean(this.editor?.commands.toggleOrderedList);
    if (!orderedListEnabled)
      return x``;
    const isDisabled = this.editor == null || !(this.editor.can().toggleOrderedList() || this.editor.can().toggleBulletList?.());
    const isActive = Boolean(
      this.editor != null && isExactNodeActive(this.editor.state, "orderedList")
    );
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        type="button"
        tabindex="-1"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--ordered-list": true,
      "toolbar__button--active": isActive,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="ordered-list"
        aria-disabled=${isDisabled}
        aria-pressed=${isActive}
        data-role="toolbar-item"
        @click=${(e4) => {
      if (elementDisabled(e4.currentTarget)) {
        return;
      }
      this.editor?.chain().focus().toggleOrderedList().run();
    }}
      >
        <slot name="ordered-list-tooltip">
          <role-tooltip
            id="ordered-list"
            hoist
            part="toolbar__tooltip toolbar__tooltip--ordered-list"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.orderedList}
          </role-tooltip>
        </slot>
        <slot name="ordered-list-icon">${this.icons.orderedList}</slot>
      </button>
    `;
  }
  renderAttachmentButton() {
    const attachmentEnabled = Boolean(this.editor?.commands.setAttachment);
    if (!attachmentEnabled)
      return x``;
    const isDisabled = this.editor == null;
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        tabindex="-1"
        type="button"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--attach-files": true,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="attach-files"
        aria-disabled=${isDisabled}
        data-role="toolbar-item"
        @click=${this.attachFiles}
      >
        <slot name="attach-files-tooltip">
          <role-tooltip
            id="attach-files"
            hoist
            part="toolbar__tooltip toolbar__tooltip--attach-files"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.attachFiles}
          </role-tooltip>
        </slot>
        <slot name="attach-files-icon">${this.icons.attachFiles}</slot>

        <!-- @TODO: Write documentation. Hookup onchange to the slotted elements? -->
        <slot name="attach-files-input">
          <input
            id="file-input"
            type="file"
            hidden
            multiple
            accept=${this.accept || "*"}
            @change=${this.handleFileUpload}
          />
        </slot>
      </button>
    `;
  }
  renderUndoButton() {
    const undoEnabled = Boolean(this.editor?.commands.undo);
    if (!undoEnabled)
      return x``;
    const isDisabled = this.editor == null || !this.editor.can().undo();
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        type="button"
        tabindex="-1"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--undo": true,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="undo"
        aria-disabled=${isDisabled}
        data-role="toolbar-item"
        @click=${(e4) => {
      if (elementDisabled(e4.currentTarget)) {
        return;
      }
      this.editor?.chain().focus().undo().run();
    }}
      >
        <slot name="undo-tooltip">
          <role-tooltip
            id="undo"
            hoist
            part="toolbar__tooltip toolbar__tooltip--undo"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.undo}
          </role-tooltip>
        </slot>
        <slot name="undo-icon">${this.icons.undo}</slot>
      </button>
    `;
  }
  renderDecreaseIndentation() {
    const decreaseIndentationNotEnabled = this.starterKitOptions.decreaseIndentation == false;
    if (decreaseIndentationNotEnabled)
      return x``;
    const isDisabled = this.editor == null || !this.editor.can().liftListItem("listItem");
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        type="button"
        tabindex="-1"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--decrease-indentation": true,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="decrease-indentation"
        aria-disabled=${isDisabled}
        data-role="toolbar-item"
        @click=${(e4) => {
      if (elementDisabled(e4.currentTarget)) {
        return;
      }
      this.editor?.chain().focus().liftListItem("listItem").run();
    }}
      >
        <slot name="decrease-indentation-tooltip">
          <role-tooltip
            id="decrease-indentation"
            hoist
            part="toolbar__tooltip toolbar__tooltip--decrease-indentation"
          >
            ${this.translations.decreaseIndentation}
          </role-tooltip>
        </slot>
        <slot name="decrease-indentation"
          >${this.icons.decreaseIndentation}</slot
        >
      </button>
    `;
  }
  renderIncreaseIndentation() {
    const increaseIndentationNotEnabled = this.starterKitOptions.increaseIndentation == false;
    if (increaseIndentationNotEnabled)
      return x``;
    const isDisabled = this.editor == null || !this.editor.can().sinkListItem("listItem");
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        type="button"
        tabindex="-1"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--increase-indentation": true,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="increase-indentation"
        aria-disabled=${isDisabled}
        data-role="toolbar-item"
        @click=${(e4) => {
      if (elementDisabled(e4.currentTarget)) {
        return;
      }
      this.editor?.chain().focus().sinkListItem("listItem").run();
    }}
      >
        <slot name="increase-indentation-tooltip">
          <role-tooltip
            id="increase-indentation"
            hoist
            part="toolbar__tooltip toolbar__tooltip--increase-indentation"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.increaseIndentation}
          </role-tooltip>
        </slot>
        <slot name="increase-indentation"
          >${this.icons.increaseIndentation}</slot
        >
      </button>
    `;
  }
  renderRedoButton() {
    const redoEnabled = Boolean(this.editor?.commands.redo);
    if (!redoEnabled)
      return x``;
    const isDisabled = this.editor == null || !this.editor.can().redo?.();
    return x`
      <button
        class="toolbar__button rhino-toolbar-button"
        tabindex="-1"
        type="button"
        part=${stringMap({
      toolbar__button: true,
      "toolbar__button--redo": true,
      "toolbar__button--disabled": isDisabled
    })}
        aria-describedby="redo"
        aria-disabled=${isDisabled}
        data-role="toolbar-item"
        @click=${(e4) => {
      if (elementDisabled(e4.currentTarget)) {
        return;
      }
      this.editor?.chain().focus().redo().run();
    }}
      >
        <slot name="redo-tooltip">
          <role-tooltip
            id="redo"
            hoist
            part="toolbar__tooltip toolbar__tooltip--redo"
            exportparts=${this.__tooltipExportParts}
          >
            ${this.translations.redo}
          </role-tooltip>
        </slot>
        <slot name="redo-icon">${this.icons.redo}</slot>
      </button>
    `;
  }
  renderToolbarStart() {
    return x``;
  }
  renderToolbarEnd() {
    return x``;
  }
  renderToolbar() {
    if (this.readonly)
      return x``;
    return x`
      <slot name="toolbar">
        <role-toolbar
          class="toolbar"
          part="toolbar"
          role="toolbar"
          exportparts="base:toolbar__base"
        >
          <slot name="toolbar-start">${this.renderToolbarStart()}</slot>

          <!-- Bold -->
          <slot name="before-bold-button"></slot>
          <slot name="bold-button">${this.renderBoldButton()}</slot>
          <slot name="after-bold-button"></slot>

          <!-- Italic -->
          <slot name="before-italic-button"></slot>
          <slot name="italic-button">${this.renderItalicButton()}</slot>
          <slot name="after-italic-button"></slot>

          <!-- Strike -->
          <slot name="before-strike-button"></slot>
          <slot name="strike-button">${this.renderStrikeButton()}</slot>
          <slot name="after-strike-button"></slot>

          <!-- Link -->
          <slot name="before-link-button"></slot>
          <slot name="link-button">${this.renderLinkButton()}</slot>
          <slot name="after-link-button"></slot>

          <!-- Heading -->
          <slot name="before-heading-button"></slot>
          <slot name="heading-button">${this.renderHeadingButton()}</slot>
          <slot name="after-heading-button"></slot>

          <!-- Blockquote -->
          <slot name="before-blockquote-button"></slot>
          <slot name="blockquote-button">${this.renderBlockquoteButton()}</slot>
          <slot name="after-blockquote-button"></slot>

          <!-- Code block -->
          <slot name="before-code-block-button"></slot>
          <slot name="code-block-button">${this.renderCodeBlockButton()}</slot>
          <slot name="after-code-block-button"></slot>

          <!-- Bullet List -->
          <slot name="before-bullet-list-button"></slot>
          <slot name="bullet-list-button"
            >${this.renderBulletListButton()}</slot
          >
          <slot name="after-bullet-list-button"></slot>

          <!-- Ordered list -->
          <slot name="before-ordered-list-button"></slot>
          <slot name="ordered-list-button">
            ${this.renderOrderedListButton()}
          </slot>
          <slot name="after-ordered-list-button"></slot>

          <slot name="before-decrease-indentation-button"></slot>
          <slot name="decrease-indentation-button"
            >${this.renderDecreaseIndentation()}</slot
          >
          <slot name="after-decrease-indentation-button"></slot>

          <slot name="before-increase-indentation-button"></slot>
          <slot name="increase-indentation-button"
            >${this.renderIncreaseIndentation()}</slot
          >
          <slot name="after-increase-indentation-button"></slot>

          <!-- Attachments -->
          <slot name="before-attach-files-button"></slot>
          <slot name="attach-files-button"
            >${this.renderAttachmentButton()}</slot
          >
          <slot name="after-attach-files-button"></slot>

          <!-- Undo -->
          <slot name="before-undo-button"></slot>
          <!-- @ts-expect-error -->
          <slot name="undo-button"> ${this.renderUndoButton()} </slot>
          <slot name="after-undo-button"></slot>

          <!-- Redo -->
          <slot name="before-redo-button"></slot>
          <slot name="redo-button"> ${this.renderRedoButton()} </slot>
          <slot name="after-redo-button"></slot>

          <slot name="toolbar-end">${this.renderToolbarEnd()}</slot>
        </role-toolbar>
      </slot>
    `;
  }
  /** @TODO: Lets think of a more friendly way to render dialogs for users to extend. */
  renderDialog() {
    if (this.readonly) {
      return x``;
    }
    return x` <div
      id="link-dialog"
      class="link-dialog"
      part="link-dialog"
      ?hidden=${!this.linkDialogExpanded}
    >
      <div class="link-dialog__container" part="link-dialog__container">
        <input
          id="link-dialog__input"
          class=${`link-dialog__input ${this.__invalidLink__ ? "link-validate" : ""}`}
          part=${`link-dialog__input ${this.__invalidLink__ ? "link-dialog__input--invalid" : ""}`}
          type="text"
          placeholder="Enter a URL..."
          aria-label="Enter a URL"
          required
          type="url"
          ${n2(this.linkInputRef)}
          @input=${() => {
      const inputElement = this.linkInputRef.value;
      if (inputElement == null)
        return;
      inputElement.setCustomValidity("");
      this.__invalidLink__ = false;
    }}
          @blur=${() => {
      const inputElement = this.linkInputRef.value;
      if (inputElement == null)
        return;
      this.__invalidLink__ = false;
    }}
          @keydown=${(e4) => {
      if (e4.key?.toLowerCase() === "enter") {
        e4.preventDefault();
        this.addLink();
      }
    }}
        />
        <div class="link-dialog__buttons" part="link-dialog__buttons">
          <button
            class="rhino-toolbar-button link-dialog__button"
            part="link-dialog__button link-dialog__button--link"
            @click=${this.addLink}
          >
            ${this.translations.linkDialogLink}
          </button>
          <button
            class="rhino-toolbar-button link-dialog__button"
            part="link-dialog__button link-dialog__button--unlink"
            @click=${() => {
      this.editor?.chain().focus().extendMarkRange("link").unsetLink().run();
    }}
          >
            ${this.translations.linkDialogUnlink}
          </button>
        </div>
      </div>
    </div>`;
  }
};
function elementDisabled(element) {
  if (element == null)
    return true;
  if (!("getAttribute" in element))
    return true;
  return element.getAttribute("aria-disabled") === "true" || element.hasAttribute("disabled");
}

export {
  TipTapEditor
};
/*! Bundled license information:

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-IATVRNQG.js.map
