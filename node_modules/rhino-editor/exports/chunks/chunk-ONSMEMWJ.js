import {
  FileAcceptEvent
} from "./chunk-MRDAN7TF.js";
import {
  BeforeInitializeEvent
} from "./chunk-35YI4Z5R.js";
import {
  AddAttachmentEvent
} from "./chunk-AI4YKHL2.js";
import {
  SelectionChangeEvent
} from "./chunk-DLTGY26Z.js";
import {
  RhinoFocusEvent
} from "./chunk-UEY2XW6A.js";
import {
  RhinoChangeEvent
} from "./chunk-K2D7UQTD.js";
import {
  RhinoBlurEvent
} from "./chunk-R7KHYLW6.js";
import {
  InitializeEvent
} from "./chunk-YVWOMDSG.js";
import {
  editor_default
} from "./chunk-SW4QD223.js";
import {
  RhinoStarterKit
} from "./chunk-SUTM2XWA.js";
import {
  AttachmentUpload
} from "./chunk-R443YRCN.js";
import {
  AttachmentManager
} from "./chunk-AWEJYXNL.js";
import {
  AttachmentEditor,
  BaseElement
} from "./chunk-K62DARNL.js";
import {
  tipTapCoreStyles
} from "./chunk-4HL6XB2M.js";
import {
  normalize
} from "./chunk-PA75CBW2.js";

// src/exports/elements/tip-tap-editor-base.ts
import { Editor } from "@tiptap/core";
import StarterKit from "@tiptap/starter-kit";
import {
  html
} from "lit";
import { DOMSerializer } from "@tiptap/pm/model";
var TipTapEditorBase = class extends BaseElement {
  constructor() {
    super();
    // Instance
    /**
     * Whether or not the editor should be editable.
     *
     * NOTE: a user can change this in the browser dev tools, don't rely on this to prevent
     * users from editing and attempting to save the document.
     */
    this.readonly = false;
    /**
     * Prevents premature rebuilds.
     */
    this.hasInitialized = false;
    /**
     * JSON or HTML serializer used for determining the string to write to the hidden input.
     */
    this.serializer = "html";
    /** Comma separated string passed to the attach-files input. */
    this.accept = "*";
    this.starterKitOptions = {
      // We don't use the native strike since it requires configuring ActionText.
      strike: false,
      rhinoLink: {
        openOnClick: false
      }
    };
    /**
     * This will be concatenated onto RhinoStarterKit and StarterKit extensions.
     */
    this.extensions = [];
    /**
     * @internal
     */
    this.__initialAttributes = {};
    /**
     * @internal
     */
    this.__hasRendered = false;
    this.__initializationPromise__ = null;
    this.__initializationResolver__ = null;
    /**
     * Used for determining how to handle uploads.
     *   Override this for substituting your own
     *   direct upload functionality.
     */
    this.handleAttachment = (event) => {
      setTimeout(() => {
        if (event.defaultPrevented) {
          return;
        }
        const { attachment, target } = event;
        if (target instanceof HTMLElement && attachment.file) {
          const upload = new AttachmentUpload(attachment, target);
          upload.start();
        }
      });
    };
    /** Override this to prevent specific file types from being uploaded. */
    this.handleFileAccept = (_event) => {
    };
    this.handleDropFile = (_view, event, _slice, moved) => {
      if (!(event instanceof DragEvent))
        return false;
      if (moved)
        return false;
      return this.handleNativeDrop(event);
    };
    this.handlePaste = async (event) => {
      if (this.editor == null)
        return;
      if (event == null)
        return;
      if (!(event instanceof ClipboardEvent))
        return;
      const { clipboardData } = event;
      if (clipboardData == null)
        return;
      const hasFiles = clipboardData.files?.length > 0;
      if (!hasFiles)
        return;
      event.preventDefault();
      this.editor.commands.insertContent(clipboardData.items);
      const attachments = await this.handleFiles(clipboardData.files);
      if (attachments.length > 0) {
        this.editor?.chain().focus().setAttachment(attachments).run();
      }
    };
    this.__handleCreate = () => {
      this.requestUpdate();
    };
    this.__handleUpdate = () => {
      this.requestUpdate();
      if (!this.hasInitialized) {
        return;
      }
      this.updateInputElementValue();
      this.dispatchEvent(new RhinoChangeEvent());
    };
    this.__handleFocus = () => {
      this.dispatchEvent(new RhinoFocusEvent());
      this.requestUpdate();
    };
    this.__handleBlur = () => {
      this.updateInputElementValue();
      this.requestUpdate();
      this.dispatchEvent(new RhinoBlurEvent());
    };
    this.__handleSelectionUpdate = ({
      transaction
    }) => {
      this.requestUpdate();
      this.dispatchEvent(new SelectionChangeEvent({ transaction }));
    };
    this.__handleTransaction = () => {
      this.requestUpdate();
    };
    this.registerDependencies();
    this.addEventListener(AddAttachmentEvent.eventName, this.handleAttachment);
    this.addEventListener("drop", this.handleNativeDrop);
    this.addEventListener("rhino-paste", this.handlePaste);
    this.addEventListener("rhino-file-accept", this.handleFileAccept);
  }
  static get styles() {
    return [normalize, tipTapCoreStyles, editor_default];
  }
  static get properties() {
    return {
      // Attributes
      readonly: { type: Boolean, reflect: true },
      input: { reflect: true },
      class: { reflect: true },
      accept: { reflect: true },
      serializer: { reflect: true },
      // Properties
      editor: { state: true },
      editorElement: { state: true },
      starterKitOptions: { state: true },
      extensions: { state: true }
    };
  }
  __getInitialAttributes() {
    if (this.__hasRendered)
      return;
    const slottedEditor = this.slottedEditor;
    if (slottedEditor) {
      this.__initialAttributes = {};
      [...slottedEditor.attributes].forEach((attr) => {
        const { nodeName, nodeValue } = attr;
        if (nodeName && nodeValue != null) {
          this.__initialAttributes[nodeName] = nodeValue;
        }
      });
    }
    this.__hasRendered = true;
  }
  /**
   * Reset mechanism. This is called on first connect, and called anytime extensions,
   * or editor options get modified to make sure we have a fresh instance.
   */
  rebuildEditor() {
    if (!this.hasInitialized)
      return;
    const editors = this.querySelectorAll("[slot='editor']");
    this.__getInitialAttributes();
    if (this.editor)
      this.editor.destroy();
    editors.forEach((el) => {
      el.editor?.destroy();
      el.remove();
    });
    this.editor = this.__setupEditor(this);
    this.__bindEditorListeners();
    this.editorElement = this.querySelector(".ProseMirror");
    Object.entries(this.__initialAttributes)?.forEach(
      ([attrName, attrValue]) => {
        if (attrName === "class") {
          this.editorElement?.classList.add(...attrValue.split(" "));
          return;
        }
        this.editorElement?.setAttribute(attrName, attrValue);
      }
    );
    this.editorElement?.setAttribute("slot", "editor");
    this.editorElement?.classList.add("trix-content");
    this.editorElement?.setAttribute("tabindex", "0");
    this.editorElement?.setAttribute("role", "textbox");
    this.requestUpdate();
  }
  /**
   * Grabs HTML content based on a given range. If no range is given, it will return the contents
   *   of the current editor selection. If the current selection is empty, it will return an empty string.
   * @param from - The start of the selection
   * @param to - The end of the selection
   * @example Getting the HTML content of the current selection
   *    const rhinoEditor = document.querySelector("rhino-editor")
   *    rhinoEditor.getHTMLContentFromRange()
   *
   * @example Getting the HTML content of node range
   *    const rhinoEditor = document.querySelector("rhino-editor")
   *    rhinoEditor.getHTMLContentFromRange(0, 50)
   *
   * @example Getting the HTML content and falling back to entire editor HTML
   *    const rhinoEditor = document.querySelector("rhino-editor")
   *    let html = rhinoEditor.getHTMLContentFromRange()
   *    if (!html) {
   *       html = rhinoEditor.editor.getHTML()
   *    }
   */
  getHTMLContentFromRange(from, to) {
    const editor = this.editor;
    if (!editor)
      return "";
    let empty;
    if (!from && !to) {
      const currentSelection = editor.state.selection;
      from = currentSelection.from;
      to = currentSelection.to;
    }
    if (empty) {
      return "";
    }
    if (from == null) {
      return "";
    }
    if (to == null) {
      return "";
    }
    const { state } = editor;
    const htmlArray = [];
    const tempScript = document.createElement("script");
    tempScript.type = "text/plain";
    state.doc.nodesBetween(from, to, (node, _pos, parent) => {
      if (parent === state.doc) {
        tempScript.innerHTML = "";
        const serializer = DOMSerializer.fromSchema(editor.schema);
        const dom = serializer.serializeNode(node);
        tempScript.appendChild(dom);
        htmlArray.push(tempScript.innerHTML);
        tempScript.innerHTML = "";
      }
    });
    return htmlArray.join("");
  }
  /**
   * Grabs plain text representation based on a given range. If no parameters are given, it will return the contents
   *   of the current selection. If the current selection is empty, it will return an empty string.
   * @param from - The start of the selection
   * @param to - The end of the selection
   * @example Getting the Text content of the current selection
   *    const rhinoEditor = document.querySelector("rhino-editor")
   *    rhinoEditor.getTextContentFromRange()
   *
   * @example Getting the Text content of node range
   *    const rhinoEditor = document.querySelector("rhino-editor")
   *    rhinoEditor.getTextContentFromRange(0, 50)
   *
   * @example Getting the Text content and falling back to entire editor Text
   *    const rhinoEditor = document.querySelector("rhino-editor")
   *    let text = rhinoEditor.getTextContentFromRange()
   *    if (!text) {
   *       text = rhinoEditor.editor.getText()
   *    }
   */
  getTextContentFromRange(from, to) {
    const editor = this.editor;
    if (!editor) {
      return "";
    }
    let empty;
    if (!from && !to) {
      const selection = editor.state.selection;
      from = selection.from;
      to = selection.to;
      empty = selection.empty;
    }
    if (empty) {
      return "";
    }
    if (from == null) {
      return "";
    }
    if (to == null) {
      return "";
    }
    return editor.state.doc.textBetween(from, to, " ");
  }
  willUpdate(changedProperties) {
    if (changedProperties.has("class")) {
      this.classList.add("rhino-editor");
    }
    super.willUpdate(changedProperties);
  }
  updated(changedProperties) {
    if (!this.hasInitialized) {
      return super.updated(changedProperties);
    }
    if (changedProperties.has("readonly")) {
      this.editor?.setEditable(!this.readonly);
    }
    if (changedProperties.has("extensions") || changedProperties.has("serializer") || changedProperties.has("starterKitOptions") || changedProperties.has("translations")) {
      this.rebuildEditor();
    }
    if (changedProperties.has("serializer")) {
      this.updateInputElementValue();
    }
    super.updated(changedProperties);
  }
  /** Used for registering things like <role-toolbar>, <role-tooltip>, <rhino-attachment-editor> */
  registerDependencies() {
    [AttachmentEditor].forEach((el) => el.define());
  }
  get slottedEditor() {
    return this.querySelector("[slot='editor']");
  }
  async connectedCallback() {
    super.connectedCallback();
    this.__setupInitialization__();
    if (this.editor) {
      this.__unBindEditorListeners();
    }
    this.classList.add("rhino-editor");
    await this.updateComplete;
    setTimeout(() => {
      this.dispatchEvent(new BeforeInitializeEvent());
      setTimeout(async () => {
        await this.updateComplete;
        this.hasInitialized = true;
        this.rebuildEditor();
        this.dispatchEvent(new InitializeEvent());
        this.__initializationResolver__?.();
      });
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.editor?.destroy();
    this.hasInitialized = false;
    this.__initializationPromise__ = null;
    this.__initializationResolver__ = null;
  }
  __setupInitialization__() {
    if (!this.__initializationPromise__) {
      this.__initializationPromise__ = new Promise((resolve) => {
        this.__initializationResolver__ = resolve;
      });
    }
  }
  get initializationComplete() {
    this.__setupInitialization__();
    return this.__initializationPromise__;
  }
  addExtensions(...extensions) {
    if (Array.isArray(extensions)) {
      extensions = extensions.flat(1);
    }
    this.extensions = this.extensions.concat(extensions);
  }
  /**
   * Extend this to provide your own options, or override existing options.
   * The "element" is where the editor will be initialized.
   * This will be merged
   *   @example
   *    class ExtendedRhinoEditor extends TipTapEditor {
   *      editorOptions (_element: Element) {
   *        return {
   *          autofocus: true
   *        }
   *      }
   *    }
   *
   */
  editorOptions(_element) {
    return {};
  }
  /**
   * Finds the <input> element in the light dom and updates it with the value of `#serialize()`
   */
  updateInputElementValue() {
    if (this.inputElement != null && this.editor != null && !this.readonly) {
      this.inputElement.value = this.serialize();
    }
  }
  /**
   * Function called when grabbing the content of the editor. Currently supports JSON or HTML.
   */
  serialize() {
    if (this.editor == null)
      return "";
    if (this.serializer?.toLowerCase() === "json") {
      return JSON.stringify(this.editor.getJSON());
    }
    return this.editor.getHTML();
  }
  /**
   * Searches for the <input> element in the light dom to write the HTML or JSON to.
   */
  get inputElement() {
    if (this.input == null)
      return void 0;
    return document.getElementById(this.input);
  }
  async handleFiles(files) {
    if (this.editor == null)
      return [];
    if (files == null)
      return [];
    return new Promise((resolve, _reject) => {
      const fileAcceptEvents = [...files].map((file) => {
        const event = new FileAcceptEvent(file);
        this.dispatchEvent(event);
        return event;
      });
      const allowedFiles = [];
      for (let i = 0; i < fileAcceptEvents.length; i++) {
        const event = fileAcceptEvents[i];
        if (event.defaultPrevented) {
          continue;
        }
        allowedFiles.push(event.file);
      }
      const attachments = this.transformFilesToAttachments(allowedFiles);
      if (attachments == null || attachments.length <= 0)
        return;
      attachments.forEach((attachment) => {
        this.dispatchEvent(new AddAttachmentEvent(attachment));
      });
      resolve(attachments);
    });
  }
  /**
   * Handles dropped files on the component, but not on the prosemirror instance.
   */
  handleNativeDrop(event) {
    if (this.editor == null)
      return false;
    if (event == null)
      return false;
    const { dataTransfer } = event;
    if (dataTransfer == null)
      return false;
    if (dataTransfer.files.length <= 0)
      return false;
    if (event.defaultPrevented)
      return false;
    event.preventDefault();
    this.handleFiles(dataTransfer.files).then((attachments) => {
      this.editor?.chain().focus().setAttachmentAtCoords(attachments, {
        top: event.clientY,
        left: event.clientX
      }).run();
    });
    return true;
  }
  transformFilesToAttachments(files) {
    if (this.editor == null)
      return;
    if (files == null || files.length === 0)
      return;
    const attachments = [];
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      if (file == null)
        return;
      const src = URL.createObjectURL(file);
      const attachment = new AttachmentManager(
        {
          src,
          file
        },
        this.editor.view
      );
      attachments.push(attachment);
    }
    return attachments;
  }
  renderToolbar() {
    return html``;
  }
  renderDialog() {
  }
  render() {
    return html`
      ${this.renderToolbar()}
      <div class="editor-wrapper" part="editor-wrapper">
        ${this.renderDialog()}
        <div class="editor" part="editor">
          <slot name="editor">
            <div class="trix-content"></div>
          </slot>
        </div>
      </div>
    `;
  }
  allOptions(element) {
    return Object.assign(
      this.__defaultOptions(element),
      this.editorOptions(element)
    );
  }
  /**
   * Due to some inconsistencies in how Trix will render the inputElement based on if its
   * the HTML representation, or transfromed with `#to_trix_html` this gives
   * us a consistent DOM structure to parse for rich text comments.
   */
  normalizeDOM(inputElement, parser = new DOMParser()) {
    if (inputElement == null || inputElement.value == null)
      return;
    const doc = parser.parseFromString(inputElement.value, "text/html");
    const figures = [...doc.querySelectorAll("figure[data-trix-attachment]")];
    const filtersWithoutChildren = figures.filter(
      (figure) => figure.querySelector("figcaption") == null
    );
    doc.querySelectorAll("div > figure:first-child").forEach((el) => {
      el.parentElement?.classList.add("attachment-gallery");
    });
    filtersWithoutChildren.forEach((figure) => {
      const attrs = figure.getAttribute("data-trix-attributes");
      if (!attrs)
        return;
      const { caption } = JSON.parse(attrs);
      if (caption) {
        figure.insertAdjacentHTML(
          "beforeend",
          `<figcaption class="attachment__caption">${caption}</figcaption>`
        );
        return;
      }
    });
    doc.querySelectorAll(
      "figure :not(.attachment__caption--edited) .attachment__name"
    ).forEach((el) => {
      if (el.textContent?.includes(" \xB7 ") === false)
        return;
      el.insertAdjacentText("beforeend", " \xB7 ");
    });
    const body = doc.querySelector("body");
    if (body) {
      inputElement.value = body.innerHTML;
    }
  }
  /**
   * @private
   * Use a getter here so when we rebuild the editor it pulls the latest starterKitOptions
   * This is intentionally not to be configured by a user. It makes updating extensions hard.
   *  it also is a getter and not a variable so that it will rerun in case options change.
   */
  get __starterKitExtensions__() {
    return [
      StarterKit.configure(this.starterKitOptions),
      RhinoStarterKit.configure(this.starterKitOptions)
    ];
  }
  /**
   * @param {Element} element - The element that the editor will be installed onto.
   */
  __defaultOptions(element) {
    let content = this.inputElement?.value || "";
    if (content) {
      try {
        content = JSON.parse(content);
      } catch (e) {
      }
    }
    return {
      injectCSS: false,
      extensions: this.__starterKitExtensions__.concat(this.extensions),
      autofocus: false,
      element,
      content,
      editable: !this.readonly,
      editorProps: {
        handleDrop: this.handleDropFile
      }
    };
  }
  __bindEditorListeners() {
    if (this.editor == null)
      return;
    this.editor.on("focus", this.__handleFocus);
    this.editor.on("create", this.__handleCreate);
    this.editor.on("update", this.__handleUpdate);
    this.editor.on("selectionUpdate", this.__handleSelectionUpdate);
    this.editor.on("transaction", this.__handleTransaction);
    this.editor.on("blur", this.__handleBlur);
  }
  __unBindEditorListeners() {
    if (this.editor == null)
      return;
    this.editor.off("focus", this.__handleFocus);
    this.editor.off("create", this.__handleCreate);
    this.editor.off("update", this.__handleUpdate);
    this.editor.off("selectionUpdate", this.__handleSelectionUpdate);
    this.editor.off("transaction", this.__handleTransaction);
    this.editor.off("blur", this.__handleBlur);
  }
  __setupEditor(element = this) {
    if (!this.serializer || this.serializer === "html") {
      this.normalizeDOM(this.inputElement);
    }
    const editor = new Editor(this.allOptions(element));
    return editor;
  }
};
// Static
/**
 * Default registration name
 */
TipTapEditorBase.baseName = "rhino-editor";

export {
  TipTapEditorBase
};
//# sourceMappingURL=chunk-ONSMEMWJ.js.map
